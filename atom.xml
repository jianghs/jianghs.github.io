<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Life Line</title>
  
  <subtitle>Constant Dropping Wears Away A Stone</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-24T11:21:51.958Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>J</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis 缓存雪崩、击穿、穿透</title>
    <link href="http://yoursite.com/2020/03/18/Redis-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F/"/>
    <id>http://yoursite.com/2020/03/18/Redis-缓存雪崩、击穿、穿透/</id>
    <published>2020-03-18T08:08:39.000Z</published>
    <updated>2020-03-24T11:21:51.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="雪崩描述"><a href="#雪崩描述" class="headerlink" title="雪崩描述"></a>雪崩描述</h3><p>热点数据进行缓存，一般缓存是定时任务刷新或者查询不到之后去更新。</p><p>定时任务刷新会有这种情况，当 Redis Key 全部失效时，正好有大流量，此时全部直接查询数据库，导致数据库无法抗住流量。而且重启数据库后又会被新的流量打死。</p><p>同一时间大面积失效，那一瞬间Redis跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的。</p><h3 id="雪崩解决方案"><a href="#雪崩解决方案" class="headerlink" title="雪崩解决方案"></a>雪崩解决方案</h3><ol><li>在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会在同一时间大面积失效。</li><li>如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效的问题。</li><li>设置热点数据永远不过期，有更新操作就更新缓存。</li></ol><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="穿透描述"><a href="#穿透描述" class="headerlink" title="穿透描述"></a>穿透描述</h3><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。</p><h3 id="穿透解决方案"><a href="#穿透解决方案" class="headerlink" title="穿透解决方案"></a>穿透解决方案</h3><p>接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return。</p><p>从缓存取不到的数据，在数据库中也没有取到，这时也可以将对应Key的Value对写为null、位置错误、稍后重试这样的值。</p><p>布隆过滤器（Bloom Filter）这个也能很好的防止缓存穿透的发生，他的原理也很简单就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新KV再return。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="击穿描述"><a href="#击穿描述" class="headerlink" title="击穿描述"></a>击穿描述</h3><p>缓存击穿是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。</p><h3 id="击穿解决方案"><a href="#击穿解决方案" class="headerlink" title="击穿解决方案"></a>击穿解决方案</h3><p>设置热点数据永远不过期</p><p>加上互斥锁</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缓存雪崩&quot;&gt;&lt;a href=&quot;#缓存雪崩&quot; class=&quot;headerlink&quot; title=&quot;缓存雪崩&quot;&gt;&lt;/a&gt;缓存雪崩&lt;/h2&gt;&lt;h3 id=&quot;雪崩描述&quot;&gt;&lt;a href=&quot;#雪崩描述&quot; class=&quot;headerlink&quot; title=&quot;雪崩描述&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java Web 术语</title>
    <link href="http://yoursite.com/2020/03/16/Java-Web-%E6%9C%AF%E8%AF%AD/"/>
    <id>http://yoursite.com/2020/03/16/Java-Web-术语/</id>
    <published>2020-03-16T14:48:21.000Z</published>
    <updated>2020-03-21T03:40:52.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缩写的含义"><a href="#缩写的含义" class="headerlink" title="缩写的含义"></a>缩写的含义</h2><h3 id="PO"><a href="#PO" class="headerlink" title="PO"></a>PO</h3><p>PO 是 Persistant Object 的缩写，用于表示数据库中的一条记录映射成的 java 对象。PO 仅仅用于表示数据，没有任何数据操作。通常遵守 Java Bean 的规范，拥有 getter/setter 方法。</p><p>Entity 与 PO 类似。</p><h3 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h3><p>DAO 是 Data Access Object 的缩写，用于表示一个数据访问对象。使用 DAO 访问数据库，包括插入、更新、删除、查询等操作，与 PO 一起使用。DAO 一般在持久层，完全封装数据库操作，对外暴露的方法使得上层应用不需要关注数据库相关的任何信息。</p><h3 id="VO"><a href="#VO" class="headerlink" title="VO"></a>VO</h3><p>VO 是 Value Object 的缩写，用于表示一个与前端进行交互的 java 对象。有的朋友也许有疑问，这里可不可以使用 PO 传递数据？实际上，这里的 VO 只包含前端需要展示的数据即可，对于前端不需要的数据，比如数据创建和修改的时间等字段，出于减少传输数据量大小和保护数据库结构不外泄的目的，不应该在 VO 中体现出来。通常遵守 Java Bean 的规范，拥有 getter/setter 方法。</p><h3 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h3><p>DTO 是 Data Transfer Object 的缩写，用于表示一个数据传输对象。DTO 通常用于不同服务或服务不同分层之间的数据传输。DTO 与 VO 概念相似，并且通常情况下字段也基本一致。但 DTO 与 VO 又有一些不同，这个不同主要是设计理念上的，比如 API 服务需要使用的 DTO 就可能与 VO 存在差异。通常遵守 Java Bean 的规范，拥有 getter/setter 方法。</p><h3 id="BO"><a href="#BO" class="headerlink" title="BO"></a>BO</h3><p>BO 是 Business Object 的缩写，用于表示一个业务对象。BO 包括了业务逻辑，常常封装了对 DAO、RPC 等的调用，可以进行 PO 与 VO/DTO 之间的转换。BO 通常位于业务层，要区别于直接对外提供服务的服务层：BO 提供了基本业务单元的基本业务操作，在设计上属于被服务层业务流程调用的对象，一个业务流程可能需要调用多个 BO 来完成。</p><h3 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h3><p>POJO 是 Plain Ordinary Java Object 的缩写，表示一个简单 java 对象。上面说的 PO、VO、DTO 都是典型的 POJO。而 DAO、BO 一般都不是 POJO，只提供一些调用方法。</p><h2 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h2><p><img src="http://picbed.jianghs.com/pic1.jpg" alt="图1"></p><p><img src="http://picbed.jianghs.com/pic2.jpg" alt="图2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缩写的含义&quot;&gt;&lt;a href=&quot;#缩写的含义&quot; class=&quot;headerlink&quot; title=&quot;缩写的含义&quot;&gt;&lt;/a&gt;缩写的含义&lt;/h2&gt;&lt;h3 id=&quot;PO&quot;&gt;&lt;a href=&quot;#PO&quot; class=&quot;headerlink&quot; title=&quot;PO&quot;&gt;&lt;/a&gt;P
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="Java Web" scheme="http://yoursite.com/tags/Java-Web/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java web-中文编码</title>
    <link href="http://yoursite.com/2019/12/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java-web-%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81/"/>
    <id>http://yoursite.com/2019/12/11/深入理解java-web-中文编码/</id>
    <published>2019-12-11T12:19:12.000Z</published>
    <updated>2020-03-16T15:43:15.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ol><li>ASCII码：共128个，一个字节的低七位表示。</li><li>ISO-8859-1：单字节编码，最多表示256个</li><li>GB2312：双字节编码</li><li>GBK：为了扩展GB2312，与之兼容。</li><li>GB18030：可能是单字节、双字节、四字节。</li><li>UTF-16：始终用双字节表示，java内存的字符存储格式。</li><li>UTF-8：UTF-8采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以由1~6个字节组成。</li></ol><h2 id="java中需要编码的场景"><a href="#java中需要编码的场景" class="headerlink" title="java中需要编码的场景"></a>java中需要编码的场景</h2><ol><li><p>io操作：StreamEncoder类负责编码，如果没有指定CharSet，会使用本地环境默认编码。</p></li><li><p>内存操作：String.getBytes(指定编码)、CharSet.forName(指定编码)</p></li></ol><h2 id="几种编码格式的比较"><a href="#几种编码格式的比较" class="headerlink" title="几种编码格式的比较"></a>几种编码格式的比较</h2><ol><li><p>GB2312与GBK互相兼容，但是GBK范围更大。</p></li><li><p>UTF-16效率更高，字节和字符转换快，适合在本地磁盘和内存使用。但是字节流损坏无法恢复，安全性较差。</p></li><li><p>UTF-8适合在网络传输使用，安全性较好。</p></li></ol><h2 id="java-web中涉及的编解码"><a href="#java-web中涉及的编解码" class="headerlink" title="java web中涉及的编解码"></a>java web中涉及的编解码</h2><p>看一段文本的大小，看字符本身的长度是没有意义的，即使是一样的字符采用不同的编码最终存储的大小也会不同，所以从字符到字节一定要看编码类型。</p><p>Java中一个char是16个bit，相当于两个字节，所以两个汉字用char表示在内存中占用相当于4个字节的空间。</p><h3 id="URL的编解码"><a href="#URL的编解码" class="headerlink" title="URL的编解码"></a>URL的编解码</h3><p>浏览器编码URL将非ASCII字符按照某种编码格式编码成16进制数字后将每个16进制表示的字节前加上“%”。</p><p>不同的浏览器对URL的PathInfo和QueryString的编码是不一样的。</p><h3 id="服务器的解码"><a href="#服务器的解码" class="headerlink" title="服务器的解码"></a>服务器的解码</h3><ol><li>对URL的URI部分进行解码的字符集是在 connector 的\<connector uriencoding="”UTF-8”/">中定义的，如果没有定义，那么将以默认编码ISO-8859-1解析。</connector></li><li>QueryString的解码字符集要么是 Header 中 ContentType 定义的 Charset，要么就是默认的 ISO-8859-1，要使用 ContentType 中定义的编码就要将 connector 的\<connector uriencoding="”UTF-8”" usebodyencodingforuri="”true”/">中的 useBodyEncodingForURI 设置为 true。</connector></li></ol><h4 id="http-header"><a href="#http-header" class="headerlink" title="http header"></a>http header</h4><p>header中的除url的其他参数，如果是非ASCIl字符，并且未进行编码直接放入header中，会出现乱码。</p><h4 id="post表单"><a href="#post表单" class="headerlink" title="post表单"></a>post表单</h4><p>POST表单参数是通过HTTP的BODY传递到服务端的。当我们在页面上单击提交按钮时浏览器首先将根据ContentType的Charset编码格式对表单填的参数进行编码，然后提交到服务器端，在服务器端同样也是用ContentType中的字符集进行解码的。所以通过POST表单提交的参数一般不会出现问题，而且这个字符集编码是我们自己设置的。可以通过request.setCharacterEncoding(charset)来设置。</p><h4 id="http-body"><a href="#http-body" class="headerlink" title="http body"></a>http body</h4><p>编解码字符集可以通过response.setCharacterEncoding来设置。<br>访问数据库通过jdbc驱动设置编码格式，需和数据库编码保持一致。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编码&quot;&gt;&lt;a href=&quot;#编码&quot; class=&quot;headerlink&quot; title=&quot;编码&quot;&gt;&lt;/a&gt;编码&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;ASCII码：共128个，一个字节的低七位表示。&lt;/li&gt;
&lt;li&gt;ISO-8859-1：单字节编码，最多表示256个&lt;/li&gt;
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java web-java io</title>
    <link href="http://yoursite.com/2019/12/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java-web-java-io/"/>
    <id>http://yoursite.com/2019/12/10/深入理解java-web-java-io/</id>
    <published>2019-12-10T13:47:03.000Z</published>
    <updated>2020-03-16T15:43:15.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java-io-机制"><a href="#java-io-机制" class="headerlink" title="java io 机制"></a>java io 机制</h2><h3 id="io类库的基本架构"><a href="#io类库的基本架构" class="headerlink" title="io类库的基本架构"></a>io类库的基本架构</h3><ol><li><p>传输格式</p><p> 基于字节操作：InputStream和OutputStream</p><p> 基于字符操作：Writer和Reader</p></li><li><p>传输方式</p><p> 基于磁盘操作：File</p><p> 基于网络操作：Socket</p></li></ol><p>无论磁盘或者网络传输，最小的存储单元都是字节而不是字符，为什么需要基于字符操作？</p><p>因为程序中操作的数据是字符格式，而字符转成字节耗时，而且有编码的问题。</p><h2 id="字节和字符的转换"><a href="#字节和字符的转换" class="headerlink" title="字节和字符的转换"></a>字节和字符的转换</h2><ol><li>InputStreamReader 字节转字符</li><li>OutStreamWriter 字符转字节</li></ol><h2 id="磁盘IO工作机制"><a href="#磁盘IO工作机制" class="headerlink" title="磁盘IO工作机制"></a>磁盘IO工作机制</h2><h3 id="标准访问文件方式"><a href="#标准访问文件方式" class="headerlink" title="标准访问文件方式"></a>标准访问文件方式</h3><p>读：从缓存中读取，有则取出，没有则从磁盘读取，然后缓存在操作系统缓存中。</p><p>写：用户地址空间复制到内存地址空间缓存后，对于应用程序而言就是写完毕。</p><h3 id="直接IO方式"><a href="#直接IO方式" class="headerlink" title="直接IO方式"></a>直接IO方式</h3><p>应用程序直接访问磁盘空间，而不经过内存地址空间缓存。</p><h3 id="同步访问文件方式"><a href="#同步访问文件方式" class="headerlink" title="同步访问文件方式"></a>同步访问文件方式</h3><p>写：只有当数据全部写入到磁盘时才会认为写入完毕。<br>性能较差，只有对数据安全性比较高的场景才会有要求。</p><h3 id="异步访问文件方式"><a href="#异步访问文件方式" class="headerlink" title="异步访问文件方式"></a>异步访问文件方式</h3><p>当访问数据的请求发出去后，应用程序线程不会阻塞，而是去处理其他任务。<br>可以提高应用程序效率而无法提高文件访问效率。</p><h3 id="内存映射方式"><a href="#内存映射方式" class="headerlink" title="内存映射方式"></a>内存映射方式</h3><p>将内存中某块区域与磁盘中的文件关联，访问内存区域时相当于直接访问磁盘文件。</p><h2 id="网络IO工作机制"><a href="#网络IO工作机制" class="headerlink" title="网络IO工作机制"></a>网络IO工作机制</h2><p>影响网络传输的因素</p><ol><li>网络带宽</li><li>传输距离</li><li>TCP拥塞控制</li></ol><h2 id="java-socket-工作机制"><a href="#java-socket-工作机制" class="headerlink" title="java socket 工作机制"></a>java socket 工作机制</h2><p>客户端：Socket 实例，创建实例成功之前将进行tcp三次握手。</p><p>服务端：SocketServer 实例。</p><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><ol><li>客户端每个Socket实例都会有一个InputStream和一个OutputStream，并通过这两个对象来交换数据。</li><li>写入端将数据写入到OutputStream对应的SendQ队列中，读取端从InputStream对应的RecvQ队列中读取数据。</li><li>网络io的读取和写入有一个协同的过程，如果两边同时传输数据，可能产生死锁。</li></ol><h2 id="NIO的工作方式"><a href="#NIO的工作方式" class="headerlink" title="NIO的工作方式"></a>NIO的工作方式</h2><p>BIO的弊端</p><ol><li>难以解决线程数过多的问题</li><li>线程优先级难以控制</li><li>线程并发</li></ol><h2 id="NIO工作机制"><a href="#NIO工作机制" class="headerlink" title="NIO工作机制"></a>NIO工作机制</h2><p>Channel:比Socket更加具体，可以看作是某个具体的交通工具</p><p>Selector:调度系统，轮循每个Channel的状态。</p><p>Buffer:比Stream更加具体，可以看作车辆上的座位。</p><h3 id="两个线程"><a href="#两个线程" class="headerlink" title="两个线程"></a>两个线程</h3><p>一个线程专门监听客户端的连接请求，以阻塞的方式。</p><p>一个线程专门处理连接请求，以非阻塞的方式。</p><h2 id="Buffer的工作方式"><a href="#Buffer的工作方式" class="headerlink" title="Buffer的工作方式"></a>Buffer的工作方式</h2><p>一组基本数据类型的元素列表。</p><p>capacity:缓冲区数组的总长度。</p><p>position:下一个要操作的数据元素的位置。</p><p>limit:缓冲区数组不可操作的元素位置。</p><p>mark:记录当前position前一个位置或默认为0。</p><h2 id="NIO数据访问方式"><a href="#NIO数据访问方式" class="headerlink" title="NIO数据访问方式"></a>NIO数据访问方式</h2><ol><li><p>FileChannel.TransferTo/FileChannel.TransferFrom 数据直接在内核空间中移动</p></li><li><p>FileChannel.TransferMap 将文件按照一定大小块映射为内存空间，将程序访问这个内存空间时将直接操作这个文件，省去从内核空间到用户空间的复制的过程，适合大文件读的操作。</p></li></ol><h2 id="IO调优"><a href="#IO调优" class="headerlink" title="IO调优"></a>IO调优</h2><p>1、磁盘IO优化</p><ul><li>增加缓存，减少磁盘访问次数。</li><li>合适的磁盘管理和磁盘策略。</li><li>设计合适的磁盘存储数据块和访问这些数据块的策略。</li><li>合理的RAID策略</li></ul><p>2、网络IO优化</p><ul><li>减少网络交互次数</li><li>减少网络传输数据量大小</li><li>尽量减少编码</li></ul><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步:一个任务完成依赖另一个任务，可靠的任务序列</p><p>异步:不可靠的任务序列</p><p>同步可以保证任务的可靠性，异步可以提升任务的性能。</p><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>阻塞:cpu等待任务完成后，再执行下一个任务。</p><p>非阻塞:任务执行时，cpu执行下一个任务。</p><p>非阻塞可以提高cpu利用率，但是会增加线程切换。</p><h2 id="java-io中的适配器模式"><a href="#java-io中的适配器模式" class="headerlink" title="java io中的适配器模式"></a>java io中的适配器模式</h2><p>InputStreamReader把InputStream适配成Reader</p><p>OutputStreamWriter把OutputStream适配成Writer</p><h2 id="java-io中的装饰器模式"><a href="#java-io中的装饰器模式" class="headerlink" title="java io中的装饰器模式"></a>java io中的装饰器模式</h2><p>目的是增强原有接口的功能</p><p>FilterInputStream、BufferedInputStream</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java-io-机制&quot;&gt;&lt;a href=&quot;#java-io-机制&quot; class=&quot;headerlink&quot; title=&quot;java io 机制&quot;&gt;&lt;/a&gt;java io 机制&lt;/h2&gt;&lt;h3 id=&quot;io类库的基本架构&quot;&gt;&lt;a href=&quot;#io类库的基本架构&quot; c
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java web-web请求过程</title>
    <link href="http://yoursite.com/2019/12/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java-web-web%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/12/10/深入理解java-web-web请求过程/</id>
    <published>2019-12-10T13:33:48.000Z</published>
    <updated>2020-03-16T15:43:15.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web-请求过程"><a href="#web-请求过程" class="headerlink" title="web 请求过程"></a>web 请求过程</h2><p>浏览器缓存</p><ol><li>catch-control/pragma</li><li>expires</li><li>lastmodified/etag</li></ol><p>资源的最后修改时间/让服务端给每个页面分配唯一id</p><h2 id="dns解析过程"><a href="#dns解析过程" class="headerlink" title="dns解析过程"></a>dns解析过程</h2><ol><li>浏览器检查缓存（ttl属性控制）</li><li>操作系统缓存（）</li><li>LDNS（网络设置的DNS服务器地址）</li><li>root server 域名服务器</li><li>根域名服务器返回给本地域名服务器一个主域名服务器地址</li><li>本地域名服务器向主域名服务器发送请求</li></ol><h2 id="域名缓存"><a href="#域名缓存" class="headerlink" title="域名缓存"></a>域名缓存</h2><ol><li>local dns server</li><li>用户本地机器</li></ol><h2 id="域名解析方式"><a href="#域名解析方式" class="headerlink" title="域名解析方式"></a>域名解析方式</h2><ol><li>A记录-多个域名解析到一个ip。</li><li>MX记录-将某个域名下的邮件服务器指向自己的ip。</li><li>CNAME-别名解析，将一个域名设置为多个别名。</li><li>NS记录-为某个域名指定DNS服务器。</li><li>TXT记录-为某个主机名或者域名设置说明。</li></ol><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>内容分布网络，先进的流量分发网络。</p><p>CDN = 镜像 + 缓存 + 负载均衡</p><p>首先去CDN拿文件，如果CDN没有，则去源站拿这个文件。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>对工作任务平衡、分摊到多个工作单元上。</p><h3 id="链路负载均衡"><a href="#链路负载均衡" class="headerlink" title="链路负载均衡"></a>链路负载均衡</h3><p>通过dns解析成不同的ip，然后指向不同的应用服务器。</p><p>优点：直接访问目标服务器，速度比较快。</p><p>缺点：dns在本地和local dns server存在缓存，一旦目标服务器挂掉，dns没有及时更新域名解析，会出现用户无法访问。</p><h3 id="集群负载均衡"><a href="#集群负载均衡" class="headerlink" title="集群负载均衡"></a>集群负载均衡</h3><ol><li>硬件负载，如F5。性能好，价格昂贵，流量陡增时无法动态扩展。</li><li>软件负载。廉价，经过多层代理，增加网络延时。</li></ol><h3 id="操作系统负载均衡"><a href="#操作系统负载均衡" class="headerlink" title="操作系统负载均衡"></a>操作系统负载均衡</h3><p>利用操作系统级的软中断或者硬件中断实现。如设置多队列网卡实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;web-请求过程&quot;&gt;&lt;a href=&quot;#web-请求过程&quot; class=&quot;headerlink&quot; title=&quot;web 请求过程&quot;&gt;&lt;/a&gt;web 请求过程&lt;/h2&gt;&lt;p&gt;浏览器缓存&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;catch-control/pragma&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-基础知识</title>
    <link href="http://yoursite.com/2019/08/12/JavaScript-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/08/12/JavaScript-基本知识/</id>
    <published>2019-08-12T06:24:23.000Z</published>
    <updated>2020-03-16T15:43:15.707Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>function</code> 关键字声明。</p><p>语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg0, arg1, ..., argN</span>) </span>&#123;</span><br><span class="line">  statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h2><p>由于参数在 JavaScript 内部通过数组实现，所以不介意传递的参数类型和个数是否与 function 一致。</p><p>命名的参数只提供便利，不是必须的。参数可以通过 <code>arguments</code> 对象访问（arguments[0]…）。</p><p>没有传递值的命名参数将自动被赋予 undefined 值。</p><h2 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h2><p>如果定义了两个名字相同的函数，该名字只属于后定义的函数。</p><h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><h3 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h3><p>只能给引用类型动态的添加属性，不能给基本类型动态的添加。</p><h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><p>基本类型：在变量位置创建一个新值，然后把值复制到为新变量分配的位置上。</p><p>引用类型：复制的是引用，指向的是同一个对象。</p><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>参数传递都是值传递。</p><h3 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h3><p>检测基本类型：<code>typeof</code></p><p>检测引用类型：<code>instanceof</code></p><h2 id="执行环境和作用域"><a href="#执行环境和作用域" class="headerlink" title="执行环境和作用域"></a>执行环境和作用域</h2><p>执行环境定义了变量和函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都一个与之关联的<code>变量对象</code>。</p><p>全局执行环境是最外围的一个执行环境，由宿主环境决定。</p><p>某个执行环境中的所有代码执行完毕后，该环境会被销毁，保存在其中的所有变量和函数也会被销毁。</p><p>作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。</p><p>作用域链的最前端始终都是当前执行的代码所在环境的变量对象。全局对象始终是作用域链最后一个对象。</p><h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><ul><li>try-catch 语句的 catch 块</li><li>with 语句</li></ul><h3 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h3><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><ul><li><code>var person = new Object()</code></li><li><p>字面量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name : <span class="string">"dd"</span>,</span><br><span class="line">  age : <span class="number">20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h3><p>函数声明提升，解释器在向执行环境中加载数据时，会先读取函数声明，并使其在执行任何代码之前可用。函数表达式必须等到执行时才会真正被解释执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 &lt;code&gt;function&lt;/code&gt; 关键字声明。&lt;/p&gt;
&lt;p&gt;语法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript DOM</title>
    <link href="http://yoursite.com/2019/08/09/JavaScript-DOM/"/>
    <id>http://yoursite.com/2019/08/09/JavaScript-DOM/</id>
    <published>2019-08-09T07:26:22.000Z</published>
    <updated>2020-03-16T15:43:15.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li>属性 Object.property</li><li>方法 Object.method()</li></ul><p>如 Person.age\Person.get()</p><h4 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h4><ol><li><p>内建对象：语言本身的对象，如 new Date(),new Array()等。</p></li><li><p>宿主对象：browser or node</p></li><li><p>用户自定义对象。</p></li></ol><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="文档-D"><a href="#文档-D" class="headerlink" title="文档 - D"></a>文档 - D</h3><p>DOM 将编写的网页文档转换成文档对象。</p><h3 id="对象-O"><a href="#对象-O" class="headerlink" title="对象 - O"></a>对象 - O</h3><p>windows 对象对应这浏览器本身，这个对象的属性和方法通常统称为 BOM （浏览器对象模型）</p><h3 id="模型-M"><a href="#模型-M" class="headerlink" title="模型 - M"></a>模型 - M</h3><p>某种事物的表现形式。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><h4 id="元素节点"><a href="#元素节点" class="headerlink" title="元素节点"></a>元素节点</h4><p>DOM 的原子。</p><p>这些节点构成了文档的结构。</p><h4 id="文本节点"><a href="#文本节点" class="headerlink" title="文本节点"></a>文本节点</h4><p>表示 DOM 的具体文本。</p><h4 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h4><p>对元素更具体的描述。</p><p>所有的属性节点都被元素节点包含。</p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">selector</span> &#123;</span><br><span class="line">  <span class="attribute">property </span>: value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点树上的各个元素将继承父元素的样式属性。</p><h4 id="class-属性"><a href="#class-属性" class="headerlink" title="class 属性"></a>class 属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"special"</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.special</span> &#123;</span><br><span class="line">  <span class="attribute">font-style </span>: italic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="id-属性"><a href="#id-属性" class="headerlink" title="id 属性"></a>id 属性</h4><p>独一无二的标识符。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"special"</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#special</span> &#123;</span><br><span class="line">  <span class="attribute">font-style </span>: italic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><ol><li>getElementById: 通过元素 ID</li><li>getElementByTagName: 通过标签名字，返回一个数组</li><li>getElementByClassName: 通过类名字，返回一个数组</li></ol><h3 id="获取和设置属性"><a href="#获取和设置属性" class="headerlink" title="获取和设置属性"></a>获取和设置属性</h3><p>getAttribute</p><p>setAttribute</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>平稳退化：确保网页在没有 JavaScript 的情况下也能正常工作。</p><p>分离 JavaScript：把网页结构内容与脚本动作行为分开。</p><p>向后兼容性：确保老浏览器不会因为脚本死掉。</p><p>性能考虑：脚本执行性能最优。</p><h2 id="创建动态标记"><a href="#创建动态标记" class="headerlink" title="创建动态标记"></a>创建动态标记</h2><h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><p>创建元素节点</p><h3 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild"></a>appendChild</h3><h3 id="createTextNode"><a href="#createTextNode" class="headerlink" title="createTextNode"></a>createTextNode</h3><p>创建文本节点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;h3 id=&quot;对象&quot;&gt;&lt;a href=&quot;#对象&quot; class=&quot;headerlink&quot; title=&quot;对象&quot;&gt;&lt;/a&gt;对象&lt;/h3&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Redis-多机数据库的实现</title>
    <link href="http://yoursite.com/2019/07/29/Redis-%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/07/29/Redis-多机数据库的实现/</id>
    <published>2019-07-29T07:02:36.000Z</published>
    <updated>2020-03-21T03:38:54.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>通过 <code>SLAVEOF</code> 命令或者设置 slaveof 选项，启动复制功能。</p><h3 id="旧版复制功能的实现"><a href="#旧版复制功能的实现" class="headerlink" title="旧版复制功能的实现"></a>旧版复制功能的实现</h3><ul><li>同步（SYNC）：将从服务器数据更新至主服务器当前所处的数据状态。</li><li>命令传播（command propagate）:在主服务器数据发生修改，导致主从服务器不一致时，让主从服务器回到一致状态。</li></ul><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ol><li>从服务器向主服务器发送 SYNC 命令。</li><li>收到 SYNC 命令的主服务器执行 BGSAVE 命令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有写命令。</li><li>当主服务器的 BGSAVE 命令执行完毕时，主服务器会将生成的 RDB 文件发送给从服务器，从服务器接收并载入这个 RDB 文件，将自己的数据库状态更新至主服务器执行 BGSAVE 时的数据库状态。</li><li>主服务器将记录在缓冲区的所有写命令发送给从服务器，从服务器执行这些写命令，将数据库状态更新到主服务器数据库当前所处的状态。</li></ol><h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><p>主服务器对从服务器执行命令传播操作。</p><h3 id="旧版复制功能的缺陷"><a href="#旧版复制功能的缺陷" class="headerlink" title="旧版复制功能的缺陷"></a>旧版复制功能的缺陷</h3><p>断线后重新复制，主服务器接收到 SYNC 命令后会将所有的数据生成 RDB 文件，导致效率低下。</p><h3 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="headerlink" title="新版复制功能的实现"></a>新版复制功能的实现</h3><p><code>PSYNC</code> 命令具备完整重同步和部分重同步两种模式。</p><p>完整重同步用于初次复制情况，与 SYNC 功能一致。</p><p>部分重同步用于断线后重新复制的情况，断线后，如果条件允许，只复制断线期间的写命令。</p><ol><li>从服务器向主服务器发送 PSYNC 命令。</li><li>主服务器向从服务器回复 +CONTINUE 回复，表示执行部分重同步。</li><li>从服务器接收 +CONTINUE 回复，准备执行部分重同步。</li></ol><h3 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h3><h4 id="主服务器的复制偏移量和从服务器的复制偏移量"><a href="#主服务器的复制偏移量和从服务器的复制偏移量" class="headerlink" title="主服务器的复制偏移量和从服务器的复制偏移量"></a>主服务器的复制偏移量和从服务器的复制偏移量</h4><ol><li>主服务器每次向从服务器传播 N 个字节数据时，就将自己的复制偏移量加 N。</li><li>从服务器接收到 N 个字节数据时，就将自己的复制偏移量加 N。</li></ol><p>如果主从服务器的复制偏移量相等，则数据库状态一致。否则处于不一致的状态。</p><h4 id="主服务器的复制积压缓冲区"><a href="#主服务器的复制积压缓冲区" class="headerlink" title="主服务器的复制积压缓冲区"></a>主服务器的复制积压缓冲区</h4><p>复制积压缓冲区是主服务器维护的一个固定长度、先进先出的队列。默认大小 1 MB。</p><p>积压缓冲区会记录每个字节对应的偏移量。</p><ol><li>当主服务器进行命令传播时，不仅会把所有写命令发给所有从服务器，还会将写命令入队到复制积压缓冲区。</li><li>主服务器接收到从服务器的 PSYNC 命令后，如果从服务器复制偏移量之后的数据仍然存在于积压缓冲区，那么主服务器会对从服务器执行部分重同步。</li><li>否则执行完整重同步。</li></ol><h4 id="服务器的运行-ID"><a href="#服务器的运行-ID" class="headerlink" title="服务器的运行 ID"></a>服务器的运行 ID</h4><p>从服务器进行初次复制时，主服务器会将自己的服务器 ID 发送给从服务器，从服务器会保存这个 ID。</p><p>如果从服务器保存的 ID 与 重新连接的服务器 ID 相同，主服务器可以继续尝试部分重同步。否则进行完整重同步。</p><h3 id="PSYNC-命令的实现"><a href="#PSYNC-命令的实现" class="headerlink" title="PSYNC 命令的实现"></a>PSYNC 命令的实现</h3><p><img src="http://picbed.jianghs.com/PSYNC_PROCESS.png" alt="PSYNC 情况"></p><h3 id="复制的实现"><a href="#复制的实现" class="headerlink" title="复制的实现"></a>复制的实现</h3><ol><li><p>设置主服务器的地址和端口</p><p> 从服务器的 redisServer 的 masterhost 属性和 masterport 属性记录以上信息。</p></li><li><p>建立套接字连接</p><p> 从服务器是主服务器的客户端。</p></li><li><p>发送 PING 命令</p><ul><li>检查套接字是否读写正常。</li><li><p>检查主服务器是否可以正常处理命令请求。</p><p><img src="http://picbed.jianghs.com/PING.png" alt="ping"></p></li></ul></li><li><p>身份验证</p><p> <img src="http://picbed.jianghs.com/verify.png" alt="verify"></p></li><li><p>发送端口信息</p><p> 从服务器向主服务器发送自己的端口信息，主服务器将从服务器的端口记录在 redisClient 中。</p></li><li><p>进行同步</p><p> 从服务器向主服务器发送 PSYNC 命令，执行同步操作。</p><p> 执行同步前，只有从服务器是主服务器是客户端，执行同步后，主从服务器互为客户端。</p></li><li><p>进行命令传播</p><p> 完成同步后，主从服务器就会进入命令传播阶段。</p></li></ol><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>命令传播阶段，从服务器默认每秒一次的频率，向主服务器发送以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK &lt;replication_offset&gt;</span><br></pre></td></tr></table></figure><p>作用：</p><ul><li>检测主从服务器网络连接状态</li><li>辅助实现 min-slaves 选项</li><li>检测命令丢失</li></ul><h4 id="检测主从服务器网络连接状态"><a href="#检测主从服务器网络连接状态" class="headerlink" title="检测主从服务器网络连接状态"></a>检测主从服务器网络连接状态</h4><p>如果主服务器一秒内没有收到从服务器发送的命令，认为网络有问题。</p><h4 id="辅助实现-min-slaves-选项"><a href="#辅助实现-min-slaves-选项" class="headerlink" title="辅助实现 min-slaves 选项"></a>辅助实现 min-slaves 选项</h4><p>min-salves-to-write 和 min-slaves-max-lag 防止主服务器在不安全的情况下执行写操作。</p><h4 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a>检测命令丢失</h4><p>与部分重同步原理类似，区别在于检测命令丢失不是在断线的情况下。</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>哨兵解决方案：由一个或者多个 sentinel 实例组成的 sentinel 系统可以监视任意多个主服务器以及这些主服务器属下的所有从服务器。</p><h3 id="启动并初始化-Sentinel"><a href="#启动并初始化-Sentinel" class="headerlink" title="启动并初始化 Sentinel"></a>启动并初始化 Sentinel</h3><h4 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h4><p>Sentinel 服务器本质上是一个 Redis 服务器，但是初始化过程不完全一致。</p><p><img src="http://picbed.jianghs.com/Sentinel-init.png" alt="Sentinel-init"></p><h4 id="将普通-Redis-服务器使用的代码替换成-Sentinel-专用代码"><a href="#将普通-Redis-服务器使用的代码替换成-Sentinel-专用代码" class="headerlink" title="将普通 Redis 服务器使用的代码替换成 Sentinel 专用代码"></a>将普通 Redis 服务器使用的代码替换成 Sentinel 专用代码</h4><p>指定自己的端口和载入自己的命令。</p><h4 id="初始化-Sentinel-状态"><a href="#初始化-Sentinel-状态" class="headerlink" title="初始化 Sentinel 状态"></a>初始化 Sentinel 状态</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前纪元，用于实现故障转移</span></span><br><span class="line">  <span class="keyword">unit64_t</span> current_epoch;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存了所有被这个 sentinel 监视的主服务器</span></span><br><span class="line">  <span class="comment">// 字典的键是主服务器的名字</span></span><br><span class="line">  <span class="comment">// 字典的值时指向 sentinelRedisInstance 结构的指针</span></span><br><span class="line">  dict *masters;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否进入 TILT 模式</span></span><br><span class="line">  <span class="keyword">int</span> tilt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 目前正在执行的脚本的数量</span></span><br><span class="line">  <span class="keyword">int</span> running_scripts;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入 TILT 模式的时间</span></span><br><span class="line">  <span class="keyword">mstime_t</span> tilt_start_time;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后一次执行时间处理器的时间</span></span><br><span class="line">  <span class="keyword">mstime_t</span> previous_time;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个 FIFO 队列，包含了所有需要执行的用户脚本</span></span><br><span class="line">  <span class="built_in">list</span> *scripts_queue;</span><br><span class="line">&#125; sentinel;</span><br></pre></td></tr></table></figure><h4 id="初始化-Sentinel-状态的-masters-属性"><a href="#初始化-Sentinel-状态的-masters-属性" class="headerlink" title="初始化 Sentinel 状态的 masters 属性"></a>初始化 Sentinel 状态的 masters 属性</h4><ul><li>字典的键是被监视的主服务器的名字</li><li>字典的值指向被监视主服务器对应的 sentinelRedisInstance 结构</li></ul><p>每个实例结构代表一被 sentinel 监控的 Redis 服务器实例，这个实例可以是主服务器、从服务器或者另一个 Sentinel。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标识值，记录了实例的类型，以及该实例的当前状态</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例的名字</span></span><br><span class="line">  <span class="comment">// 主服务器的名字由用户在配置文件中设置</span></span><br><span class="line">  <span class="comment">// 从服务器及 Sentinel 的名字由 Sentinel 自动设置</span></span><br><span class="line">  <span class="comment">// 格式为 ip:port</span></span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例的运行 ID</span></span><br><span class="line">  <span class="keyword">char</span> *runid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置纪元，用于实现故障转移</span></span><br><span class="line">  <span class="keyword">uint_64_t</span> config_epoch;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例的地址</span></span><br><span class="line">  sentinelAddr *addr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例无响应多少毫秒后才会被判断为主观下线</span></span><br><span class="line">  <span class="keyword">mstime_t</span> down_after_period;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断客观下线所需的支持投票数量</span></span><br><span class="line">  <span class="keyword">int</span> quorum;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在执行故障转移时，可以同时对新的主服务器进行同步的从服务器数量</span></span><br><span class="line">  <span class="keyword">int</span> parallel_syncs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 刷新故障转移状态的最大时限</span></span><br><span class="line">  <span class="keyword">mstime_t</span> failover_timeout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; sentinelRedisInstance;</span><br></pre></td></tr></table></figure><h4 id="创建连向主服务器的网络连接"><a href="#创建连向主服务器的网络连接" class="headerlink" title="创建连向主服务器的网络连接"></a>创建连向主服务器的网络连接</h4><p>创建两个连向主服务器的异步连接：</p><ul><li>命令连接，用于向主服务器发送命令，并接受命令回复。</li><li>订阅连接，用于订阅主服务器的 <em>sentinel</em>:hello 频道。</li></ul><h3 id="获取主服务器信息"><a href="#获取主服务器信息" class="headerlink" title="获取主服务器信息"></a>获取主服务器信息</h3><p>默认以每十秒一次的频率，通过命令连接向被监视的主服务器发送 INFO 命令，并通过分析 INFO 命令的回复来获取主服务器的当前信息。</p><ul><li>主服务器本身信息：run_id 域记录的服务器运行 ID，服务器角色。</li><li>主服务器属下所有从服务器信息：slaves 字段。</li></ul><h3 id="获取从服务器信息"><a href="#获取从服务器信息" class="headerlink" title="获取从服务器信息"></a>获取从服务器信息</h3><p>Sentinel 会创建连接到从服务器的命令连接和订阅连接。</p><p>会以每十秒一次的频率通过命令连接向从服务器发送 INFO 命令。</p><p>命令回复如下：</p><ul><li>从服务器的运行 ID run_id。</li><li>从服务器的角色 role。</li><li>主服务器的 IP 地址 master_host，以及主服务器的端口号 master_port。</li><li>主从服务器的连接状态 master_link_status。</li><li>从服务器的优先级 slave_priority。</li><li>从服务器的复制偏移量 slave_repl_offset。</li></ul><h3 id="向主服务器和从服务器发送信息"><a href="#向主服务器和从服务器发送信息" class="headerlink" title="向主服务器和从服务器发送信息"></a>向主服务器和从服务器发送信息</h3><p>默认情况下，Sentinel 会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送命令。</p><p>s_ 开头：记录的是 Sentinel 本身信息。</p><p>m_ 开头：记录的是主服务器的信息。</p><h3 id="接收来自主服务器和从服务器的频道信息"><a href="#接收来自主服务器和从服务器的频道信息" class="headerlink" title="接收来自主服务器和从服务器的频道信息"></a>接收来自主服务器和从服务器的频道信息</h3><p>对于每个与 Sentinel 连接的服务器，Sentinel 既通过命令连接向服务器的 _sentinel_:hello 频道发送信息，又通过订阅连接从服务器的 _sentinel_:hello 频道接收信息。</p><p>对于监视同一个服务器的多个 Sentinel 来说，一个 Sentinel 发送的信息会被其他 Sentinel 接收到，包括发送的 Sentinel 自身。</p><h4 id="更新-sentinels-字典"><a href="#更新-sentinels-字典" class="headerlink" title="更新 sentinels 字典"></a>更新 sentinels 字典</h4><p>Sentinel 还会记录除了自身之外的其他 Sentinels 信息。</p><h4 id="创建连向其他-Sentinel-的命令连接"><a href="#创建连向其他-Sentinel-的命令连接" class="headerlink" title="创建连向其他 Sentinel 的命令连接"></a>创建连向其他 Sentinel 的命令连接</h4><p>Sentinel 之间只会创建命令连接，不会创建订阅连接。</p><h3 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h3><p>默认情况下，Sentinel 会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他 Sentinel 在内）发送 PING 命令，并通过实例返回的 PING 命令回复来判断实例是否在线。</p><p>down-after-milliseconds 选项指定了 Sentinel 判断实例进入主观下线所需的时间长度，同样作用于监视 master 的其他 Sentinels。</p><h3 id="检测客观下线状态"><a href="#检测客观下线状态" class="headerlink" title="检测客观下线状态"></a>检测客观下线状态</h3><p>当 Sentinel 将一个主服务器判断为主观下线后，为了确认这个主服务器是否真的下线，它会向同样监视这一主服务器的其他 Sentinel 进行询问，看他们是否也认为主服务器已经进入下线状态。当接收的数量足够多时，Sentinel 就会将主服务器判定为客观下线，并执行故障转移。</p><h4 id="发送-SENTINEL-is-master-down-by-addr-命令"><a href="#发送-SENTINEL-is-master-down-by-addr-命令" class="headerlink" title="发送 SENTINEL is-master-down-by-addr 命令"></a>发送 SENTINEL is-master-down-by-addr 命令</h4><p>源 SENTINEL 服务器询问其他 SENTINEL 服务器主服务器是否已下线。</p><h4 id="接收-SENTINEL-is-master-down-by-addr-命令"><a href="#接收-SENTINEL-is-master-down-by-addr-命令" class="headerlink" title="接收 SENTINEL is-master-down-by-addr 命令"></a>接收 SENTINEL is-master-down-by-addr 命令</h4><p>目标 SENTINEL 接收到命令后，分析参数，进行命令回复。返回对主服务器的检查结果。</p><h4 id="接收-SENTINEL-is-master-down-by-addr-命令的回复"><a href="#接收-SENTINEL-is-master-down-by-addr-命令的回复" class="headerlink" title="接收 SENTINEL is-master-down-by-addr 命令的回复"></a>接收 SENTINEL is-master-down-by-addr 命令的回复</h4><p>根据其他 Sentinel 的命令回复， Sentinel 将统计其他 Sentinel 同意主服务器已下线的数量，当这一数量达到配置指定的客观下线所需数量时，会将祝福器进入客观下线状态。</p><h3 id="选举领头-Sentinel"><a href="#选举领头-Sentinel" class="headerlink" title="选举领头 Sentinel"></a>选举领头 Sentinel</h3><p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个 Sentinel 会进行协商，选举出一个领头 Sentinel，并由领头 Sentinel 对下线主观服务器执行故障转移操作。</p><p>选举的规则和方法：</p><ul><li>所有在线的 Sentinel 都有被选举为领头 Sentinel 的资格。</li><li>每次进行领头选举后，不论选举是否成功，所有 Sentinel 配置的纪元值都会自增一次。</li><li>在一个配置纪元里面，所有 Sentinel 都有一次将某个 Sentinel 设置为局部领头 Sentinel 的机会，并且局部领头一旦设置完成，在这个配置纪元里面就不能修改。</li><li>每个发现主服务器客观下线的 Sentinel 都会要求其他 Sentinel 将自己设置为局部领头 Sentinel。</li><li>Sentinel 设置局部领头 Sentinel 的规则是先到先得。</li><li>目标 Sentinel 接收到命令后，会向源 Sentinel 发送一条命令回复，回复中的 leader_runid 参数和 leader_epoch 参数分别记录了目标 Sentinel 的局部领头 Sentinel 的运行 ID 和配置纪元。</li><li>源 Sentinel 接收到目标 Sentinel 的命令回复后，检查配置纪元和自己的是否一致，如果相同，判断运行 ID 是否和自己一致，两者都一致表明目标 Sentinel 将源 Sentinel 设置为局部领头 Sentinel。</li><li>如果某个 Sentinel 被半数以上的 Sentinel 设置成了局部领头 Sentinel，那么这个 Sentinel 称为领头 Sentinel。</li><li>因为领头 Sentinel 需要半数以上的 Sentinel 的支持，并且每个 Sentinel 在每个配置纪元里面只能产生一次局部领头 Sentinel，所以在一次配置纪元里面只会出现一个领头 Sentinel。</li><li>如果在给定的时间内，没有一个 Sentinel 被选举为领头 Sentinel，那么会进行重新选举，直到选出领头 Sentinel 为止。</li></ul><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>选举出的领头 Sentinel 对已下线的主服务器进行故障转移</p><ol><li><p>在已下线的主服务器属下的所有从服务器里面，挑选一个从服务器，并将其转换为主服务器。</p><p> 挑选出一个状态良好、数据完整的从服务器，发送 SLAVEOF no one 命令。</p></li><li><p>让已下线的主服务器属下的所有从服务器改为复制新的主服务器。</p><p> 向其他从服务器发送 SLAVEOF 命令。</p></li><li><p>将已下线的主服务器设置为新主服务器的从服务器。</p><p> 已线下的服务器重新上线后，领头 Sentinel 发送 SLAVEOF 命令。</p></li></ol><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>刚开始的时候，每个节点是相互独立的，他们都处于只包含自己的集群中。</p><p>通过 <code>CLUSTER MEET</code> 命令完成。</p><h4 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h4><p>一个节点就是一个运行在集群模式下的 Redis 服务器。节点会继续使用单机模式下的服务器组件。</p><h4 id="集群数据结构"><a href="#集群数据结构" class="headerlink" title="集群数据结构"></a>集群数据结构</h4><p>每个节点都会使用一个 clusterNode 结构来记录自己的状态，并未集群中的所有其他节点（包括主节点和从节点）都创建一个相应的 clusterNode 结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 创建节点的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的名字</span></span><br><span class="line">    <span class="keyword">char</span> name[REDIS_CLUSTER_NAMELEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点标识</span></span><br><span class="line">    <span class="comment">// 使用各种不同的标识值记录节点的角色（比如主节点或者从节点）</span></span><br><span class="line">    <span class="comment">// 以及节点目前所处的状态（比如在线或者下线）</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点当前的配置纪元，用于实现故障转义</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的 IP 地址</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的端口</span></span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存连接节点所需的有关信息</span></span><br><span class="line">    clusterLink *link;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clusterNode 结构的 link 属性是一个 clusterLink 结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> sturct clusterLink &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接的创建时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCP 套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出缓冲区，保存着等待发送给其他节点的消息</span></span><br><span class="line">    sds sndbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入缓冲区，保存着从其他节点接收到的消息</span></span><br><span class="line">    sds rcvbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与这个连接相关联的节点，如果没有的话就为 NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span></span><br><span class="line">&#125; clusterLink;</span><br></pre></td></tr></table></figure><p>最后，每个节点都保存着一个 clusterState 结构，这个结构记录了在当前节点的视角下，集群目前所处的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向当前节点的指针</span></span><br><span class="line">    clusterNode *myself;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群当前的状态：上线还是下线</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群中至少处理这一个槽的节点的数量</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群节点名单</span></span><br><span class="line">    <span class="comment">// 字典的键为节点的名字，字典的值为节点对应的 clusterNode 结构</span></span><br><span class="line">    dict *nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CLUSTER-MEET-命令的实现"><a href="#CLUSTER-MEET-命令的实现" class="headerlink" title="CLUSTER MEET 命令的实现"></a>CLUSTER MEET 命令的实现</h4><p>客户端向节点 A 发送 CLUSTER MEET 命令，收到命令的节点 A 将于节点 B 进行握手。</p><ol><li><p>节点 A 会为节点 B 创建一个 clusterNode 结构，并将该结构添加到自己的 clusterState.nodes 字典里面。</p></li><li><p>之后，节点 A 将根据 CLUSTER MEET 命令给定的 IP 地址和端口号，向节点 B 发送一条 MEET 消息。</p></li><li><p>如果一切顺利，节点 B 将接受到 节点 A 发送的 MEET 消息，节点 B 会为节点 A 创建一个 clusterNode 结构，并将该结构添加到自己的 clusterState.nodes 字典里面。</p></li><li><p>之后，节点 B 将向节点 A 返回一条 PONG 消息。</p></li><li><p>节点 A 接收到节点 B 返回的 PONG 消息后，就知道节点 B 成功接收到自己发送的 MEET 消息。</p></li><li><p>之后，节点 A 将向节点 B 返回一条 PING 消息。</p></li><li><p>节点 B 将接收到节点 A 返回的 PING 消息，通过这条消息节点 B 可以知道节点 A 已经成功接到自己返回的 PONG 消息，握手完成。</p></li></ol><p>握手完成后，节点 A 会将节点 B 的信息传播到集群中的其他节点，让其他节点与节点 B 进行握手，最终，节点 B 会被集群中的所有节点认识。</p><h3 id="指派槽"><a href="#指派槽" class="headerlink" title="指派槽"></a>指派槽</h3><p>Redis 集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384 个槽，数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或者最多16384个槽。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER ADDSLOTS &lt;slot&gt; [slot ...]</span><br></pre></td></tr></table></figure><h4 id="记录节点的槽指派信息"><a href="#记录节点的槽指派信息" class="headerlink" title="记录节点的槽指派信息"></a>记录节点的槽指派信息</h4><p>clusterNode 结构的 slots 属性和 numslot 属性记录了节点负责处理那些槽。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slots[<span class="number">16384</span>/<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numslots;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传播节点的槽指派信息"><a href="#传播节点的槽指派信息" class="headerlink" title="传播节点的槽指派信息"></a>传播节点的槽指派信息</h4><p>一个节点除了将自己负责的槽记录在 clusterNode 结构的 slots 属性和 numslots 属性之外，还会将自己的 slots 数组通过消息发送给集群中的其他节点。</p><p>其他节点接收到数组后，会从自己的 clusterState.nodes 字典中查找对应的 clusterNode 结构，并对结构中的 slots 数组进行保存或者更新。</p><h4 id="记录所有槽的指派信息"><a href="#记录所有槽的指派信息" class="headerlink" title="记录所有槽的指派信息"></a>记录所有槽的指派信息</h4><p>clusterState 结构中的 slots 数组记录了集群中所有 16384 个槽的指派信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    clusterNode *slots[<span class="number">16384</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 slots[i] 指针指向 NULL，表示槽 i 尚未指派给任何节点。</li><li>如果 slots[i] 指针指向一个 clusterNode 结构，那么表示槽 i 已经指派给了 clusterNode 结构所代表的节点。</li></ul><h3 id="在集群中执行命令"><a href="#在集群中执行命令" class="headerlink" title="在集群中执行命令"></a>在集群中执行命令</h3><p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己：</p><ul><li>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。</li><li>如果没有指派给当前节点，那么节点会向客户端返回一个 MOVED 错误，指引客户端 redirect 至正确的节点，并在此发送之前的命令。</li></ul><h4 id="计算键属于哪个槽"><a href="#计算键属于哪个槽" class="headerlink" title="计算键属于哪个槽"></a>计算键属于哪个槽</h4><p>使用 <code>CLUSTER KEYSLOT &lt;key&gt;</code> 命令可以查看一个给定键属于哪个槽。</p><h4 id="判断槽是否由当前节点负责处理"><a href="#判断槽是否由当前节点负责处理" class="headerlink" title="判断槽是否由当前节点负责处理"></a>判断槽是否由当前节点负责处理</h4><p>如果 clusterState.slots[i] 等于 clusterState.myself，那么说明槽 i 由当前节点负责，节点可以执行命令。</p><p>否则，返回 MOVED 错误，并指引客户端转向至正在处理槽 i 的节点。</p><h4 id="MOVED-错误"><a href="#MOVED-错误" class="headerlink" title="MOVED 错误"></a>MOVED 错误</h4><p>错误格式：<code>MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code></p><h4 id="节点数据库的实现"><a href="#节点数据库的实现" class="headerlink" title="节点数据库的实现"></a>节点数据库的实现</h4><p>节点只能使用 0 号数据库。</p><h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><p>可以将任意数量已经指派给某个节点的槽改为指派给另一个节点，并且相关槽所属的键值对也会转移。</p><p>重写分片操作可以在线进行，并且指派的两个节点都可以继续处理命令请求。</p><h3 id="ASK-错误说明"><a href="#ASK-错误说明" class="headerlink" title="ASK 错误说明"></a>ASK 错误说明</h3><p>当客户端向源节点发送一个与数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽中。</p><ul><li>源节点优先在自己的数据库中查找指定的键，如果找到就执行命令。</li><li>如果没有找到，源节点将向客户端返回一个 ASK 错误，指引客户端转向正在导入槽的目标节点，并在此执行命令。</li></ul><h4 id="CLUSTER-SETSLOT-IMPORTING-命令的实现"><a href="#CLUSTER-SETSLOT-IMPORTING-命令的实现" class="headerlink" title="CLUSTER SETSLOT IMPORTING 命令的实现"></a>CLUSTER SETSLOT IMPORTING 命令的实现</h4><p>clusterState 结构的 importing_slots_from 数组记录了当前节点正在从其他节点导入的槽。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER SETSLOT &lt;i&gt; IMPORTING &lt;source_id&gt;</span><br></pre></td></tr></table></figure><h4 id="CLUSTER-SETSLOT-MIGRATING-命令的实现"><a href="#CLUSTER-SETSLOT-MIGRATING-命令的实现" class="headerlink" title="CLUSTER SETSLOT MIGRATING 命令的实现"></a>CLUSTER SETSLOT MIGRATING 命令的实现</h4><p>clusterState 结构的 migrating_slots_to 数组记录了当前节点正在迁移至其他节点的槽。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER SETSLOT &lt;i&gt; MIGRATING &lt;target_id&gt;</span><br></pre></td></tr></table></figure><h4 id="ASK-错误"><a href="#ASK-错误" class="headerlink" title="ASK 错误"></a>ASK 错误</h4><p>通过查找 migrating_slots_to[i]，确认 key 所属的槽 i 是否正在迁移。</p><p>如果正在迁移，则向客户端返回一个 ASK 错误，引导客户端到正在导入槽 i 的节点去查找 key。</p><h4 id="ASKING-命令"><a href="#ASKING-命令" class="headerlink" title="ASKING 命令"></a>ASKING 命令</h4><p>ASKING 命令唯一要做的就是打开发送命令客户端的 REDIS_ASKING 标识。REDIS_ASKING 是一次性标识。</p><p>节点判断是否执行客户端命令的过程</p><p><img src="http://picbed.jianghs.com/excute-client-command.png" alt="excute-client-command"></p><h4 id="ASK-错误和-MOVED-错误的区别"><a href="#ASK-错误和-MOVED-错误的区别" class="headerlink" title="ASK 错误和 MOVED 错误的区别"></a>ASK 错误和 MOVED 错误的区别</h4><ol><li>MOVED 错误代表槽的负责权已经从一个节点转移到另一个节点：在客户端收到关于槽 i 的 MOVED 错误之后，客户端每次遇到关于槽 i 的命令请求时，都可以直接将命令发送到 MOVED 错误指向的节点。</li><li>ASK 错误只是两个节点在迁移槽的过程中使用的一个临时措施：在客户端收到关于槽 i 的 ASK 错误之后，客户端只会在接下来的一次命令请求中将关于槽 i 的命令请求发送至 ASK 错误所指示的节点。</li></ol><h3 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h3><h4 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h4><p>可以让接收命令的节点称为 node_id 所指定节点的从节点，并开始对主节点进行复制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER REPLICATE &lt;node_id&gt;</span><br></pre></td></tr></table></figure><h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><p>集群中每个节点都会定期想集群中其他节点发送 PING 命令，如果接收到 PING 命令的其他节点没有在规定的时间内返回 PONG 消息，那么发送 PING 命令的节点就会将接收 PING 命令的节点标记为疑似下线（PFAIL）。</p><p>每个节点都会有一个链表，记录了所有其他节点对某个节点的下线报告。</p><p>如果在一个集群内，半数以上负责处理槽的主节点都将某个主节点 x 报告为疑似下线，那么这个节点 x 将会被标记为已下线。将 x 标记为已下线的节点将向集群广播 x 已下线的消息，其他节点收到消息都会将 x 标记为已下线。</p><h4 id="集群故障转移"><a href="#集群故障转移" class="headerlink" title="集群故障转移"></a>集群故障转移</h4><ol><li>复制下线主节点的所有从节点里面，会有一个从节点被选中。</li><li>被选中的从节点执行 SLAVEOF no one 命令，成为新的主节点。</li><li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li><li>新的主节点向集群广播一条 PONG 消息，让集群中其他节点立即知道这个节点变更为主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li><li>新的主节点开始接收和负责自己处理槽的相关命令。</li></ol><h4 id="选举新的主节点"><a href="#选举新的主节点" class="headerlink" title="选举新的主节点"></a>选举新的主节点</h4><p>与选举领头 Sentinel 类似。</p><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>MEET: 将接受者加入到接受者集群中。</p><p>PING: 检测选中的节点是否在线。</p><p>PONG: 接收到 MEET\PING 消息后回复 PONG 消息。集群内广播。</p><p>FAIL: 集群内广播某个节点已下线。</p><p>PUBLISH: 集群内广播 PUBLISH 消息，接收到消息的节点执行相同的 PUBLISH 命令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;复制&quot;&gt;&lt;a href=&quot;#复制&quot; class=&quot;headerlink&quot; title=&quot;复制&quot;&gt;&lt;/a&gt;复制&lt;/h2&gt;&lt;p&gt;通过 &lt;code&gt;SLAVEOF&lt;/code&gt; 命令或者设置 slaveof 选项，启动复制功能。&lt;/p&gt;
&lt;h3 id=&quot;旧版复制功能的实
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>JVM-性能监控与故障处理工具</title>
    <link href="http://yoursite.com/2019/07/28/JVM-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/07/28/JVM-性能监控与故障处理工具/</id>
    <published>2019-07-28T15:08:16.000Z</published>
    <updated>2020-03-16T15:43:15.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>jvm process status tool</p><p>可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier，LVMID）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></table></figure><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>jstat（JVM Statistics Monitoring Tool）是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程[插图]虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>jinfo（Configuration Info for Java）的作用是实时地查看和调整虚拟机各项参数。</p><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>Memory Map for Java 用于生成堆转储快照，一般称为 dump 文件。</p><h2 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h2><p>JVM Heap Analysis Tool,分析 dump 文件。</p><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>Stack Trace for Java 生成虚拟机当前时刻的线程快照。</p><h2 id="HSDIS"><a href="#HSDIS" class="headerlink" title="HSDIS"></a>HSDIS</h2><p>JIT 生成代码反汇编</p><h2 id="JDK-可视化工具"><a href="#JDK-可视化工具" class="headerlink" title="JDK 可视化工具"></a>JDK 可视化工具</h2><ul><li>JConsole: java 监视与管理控制台。</li><li>VisualVM：多合一故障处理工具。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jps&quot;&gt;&lt;a href=&quot;#jps&quot; class=&quot;headerlink&quot; title=&quot;jps&quot;&gt;&lt;/a&gt;jps&lt;/h2&gt;&lt;p&gt;jvm process status tool&lt;/p&gt;
&lt;p&gt;可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Clas
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Redis 单机数据库的实现</title>
    <link href="http://yoursite.com/2019/07/23/Redis-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/07/23/Redis-单机数据库的实现/</id>
    <published>2019-07-23T01:52:23.000Z</published>
    <updated>2020-03-21T03:38:45.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h3><p>结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">  <span class="comment">// 保存着服务器上所有数据库的数组</span></span><br><span class="line">  redisDb *db;</span><br><span class="line">  <span class="comment">// 服务器的数据库数量</span></span><br><span class="line">  <span class="keyword">int</span> dbnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化的时候会根据 dbnum 决定数据库的数量，默认为16。</p><h3 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h3><p>默认情况下，Redis 客户端的目标数据库是0号数据库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">  <span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">  redisDb *db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过修改 redisClient.db 指针，让它指向不同的数据库，从而实现切换数据库的功能——这个是 select 命令的实现原理。</p><h3 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h3><p>Redis 是一个键值对数据库服务器，服务器中的每个数据库结构用 dict 字典保存所有的键值对。这个字典被称为键空间。</p><p>键空间的键，也就是数据库的键，每个键都是一个字符串对象。</p><p>键空间的值，也是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象、有序集合对象中的任一 Redis 对象。</p><h4 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h4><p>实际是将一个新键值添加到键空间字典里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key &quot;value&quot;</span><br></pre></td></tr></table></figure><h4 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h4><p>实际是在键空间里删除对应的键值对对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL key</span><br></pre></td></tr></table></figure><h4 id="更新键"><a href="#更新键" class="headerlink" title="更新键"></a>更新键</h4><p>实际是对键空间的键对应的值对象进行更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key &quot;newvalue&quot;</span><br></pre></td></tr></table></figure><h4 id="对键取值"><a href="#对键取值" class="headerlink" title="对键取值"></a>对键取值</h4><p>在键空间取出键对应的值对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET key</span><br></pre></td></tr></table></figure><h4 id="其他键空间操作"><a href="#其他键空间操作" class="headerlink" title="其他键空间操作"></a>其他键空间操作</h4><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>FLUSHDB</td><td>清除数据库</td></tr><tr><td>RANDOMKEY</td><td>随机返回数据库的一个 key</td></tr><tr><td>DBSIZE</td><td>获取数据库键数量</td></tr></tbody></table><h4 id="读写键空间的维护操作"><a href="#读写键空间的维护操作" class="headerlink" title="读写键空间的维护操作"></a>读写键空间的维护操作</h4><ul><li><p>读取一个键之后，服务器会根据键是否存在更新服务器的键空间命中次数或不命中次数。</p></li><li><p>读取一个键后，服务器更新这个键的 LRU 时间。</p></li><li><p>如果服务器读取一个键时，发现键已过期，服务器会先删除过期键，然后进行后续操作。</p></li><li><p>如果客户端会用 WATCH 命令监控了某个键，那么服务器在对被监控的键进行修改后，会将这个键标记为脏（dirty）,从而让事务程序注意这个键已被修改。</p></li><li><p>服务器每修改一次键，则会对脏键计数器加一，这个计数器会触发服务器的持久化以及复制操作。</p></li><li><p>如果服务器配置了通知功能，在对键进行修改之后，服务器会根据配置发送相应的数据库通知。</p></li></ul><h3 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h3><ul><li><p>设置生存时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE keyname 5</span><br></pre></td></tr></table></figure></li><li><p>设置过期时间点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIREAT keyname 111231231</span><br></pre></td></tr></table></figure></li></ul><h4 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h4><ul><li>EXPIRE \&lt;key> \&lt;ttl> 将键 key 的生存时间设置为 ttl 秒。</li><li>PEXPIRE \&lt;key> \&lt;ttl> 将键 key 的生存时间设置为 ttl 毫秒。</li><li>EXPIREAT \&lt;key> \&lt;timestamp> 将键 key 的过期时间设置为 timestamp 指定的秒数时间戳。</li><li>PEXPIREAT \&lt;key> \&lt;timestamp> 将键 key 的生存时间设置为  timestamp 指定的毫秒时间戳。</li></ul><p>都是根据 PEXPIREAT 命令转换来执行。</p><h4 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h4><p>过期字典的键是一个指针，这个指针指向键空间的某个键对象。</p><p>过期字典的值是一个 long 类型的整数，这个整数保存了键所指向的数据库键的过期时间-一个毫秒精度的时间戳。</p><h4 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h4><p>PERSIST 命令可以移除一个键的过期时间。</p><h4 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h4><p>TTL 命令以秒为单位返回键的剩余生存时间。</p><p>PTTL 命令以毫秒为单位返回键的剩余生存时间。</p><h4 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h4><ol><li>检查给定键是否存在于过期字典，如果存在，取得键的过期时间。</li><li>如果当前时间戳大于过期时间，那么键已过期。</li></ol><h3 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h3><ul><li><p>定时删除</p><p>设置键的过期时间的同时，创建了一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。</p></li><li><p>惰性删除：</p><p>放任键过期不管，每次从键空间获取键时，检查键是否过期，如果过期的话，就删除键。</p></li><li><p>定期删除：</p><p>每隔一段时间，程序对数据库进行一次检查，删除里面的过期键。</p></li></ul><p>第一和第三种是主动删除，第二种是被动删除。</p><table><thead><tr><th>类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>定时删除</td><td>保证键尽快的被删除，释放内存</td><td>过期键较多时，占用较多 CPU 时间</td></tr><tr><td>惰性删除</td><td>不会占用过多 CPU 时间</td><td>对内存最不友好</td></tr><tr><td>定期删除</td><td>折中策略</td><td>难以确定删除操作的时长和频率</td></tr></tbody></table><h3 id="Redis-的过期键删除策略"><a href="#Redis-的过期键删除策略" class="headerlink" title="Redis 的过期键删除策略"></a>Redis 的过期键删除策略</h3><p>Redis 服务器实际采用惰性删除和定期删除策略结合的方式。</p><h3 id="AOF、RDB-和复制功能对过期键的处理"><a href="#AOF、RDB-和复制功能对过期键的处理" class="headerlink" title="AOF、RDB 和复制功能对过期键的处理"></a>AOF、RDB 和复制功能对过期键的处理</h3><h4 id="生成-RDB-文件"><a href="#生成-RDB-文件" class="headerlink" title="生成 RDB 文件"></a>生成 RDB 文件</h4><p>已过期键不会写入 RDB 文件。</p><h4 id="载入-RDB-文件"><a href="#载入-RDB-文件" class="headerlink" title="载入 RDB 文件"></a>载入 RDB 文件</h4><p>如果服务器以主服务器的方式运行，程序会对文件中的键进行过期检查，过期键会被忽略。</p><p>如果服务器以从服务器的方式运行，文件中的所有键都会载入。但是主从服务器同步数据时，从服务器数据会清空。</p><h4 id="AOF-文件写入"><a href="#AOF-文件写入" class="headerlink" title="AOF 文件写入"></a>AOF 文件写入</h4><p>当服务器以 AOF 持久化模式运行时，如果数据库中某个键已经过期，但它还没有被删除，那么 AOF 文件不会因为这个过期键产生任何影响。</p><p>当这个键被删除后，程序会向 AOF 文件追加一条 DEL 命令，显式的删除这个键。</p><h4 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h4><p>已过期键不会重写进 AOF 文件。</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>服务器运行在复制模式下时，从服务器的过期键删除由主服务器控制：</p><ol><li>主服务器删除一个过期键后，显式的向所有从服务器发送一个 DEL 命令，告知从服务器删除这个过期键。</li><li>从服务器执行客户端发来的命令时，即使碰到过期键也不会删除。</li><li>从服务器只有接受到主服务器发来的 DEL 命令时，才会删除过期键。</li></ol><h3 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h3><p>可以让客户端通过订阅给定的频道或者模式，获取数据库中键的变化，以及数据库中命令的执行情况。</p><h2 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h2><h3 id="RDB-文件的创建和载入"><a href="#RDB-文件的创建和载入" class="headerlink" title="RDB 文件的创建和载入"></a>RDB 文件的创建和载入</h3><p><code>SAVE</code> 命令会阻塞 Redis 服务器进程，直到 RDB 文件创建完成，在服务器进程阻塞期间，服务器不能处理任何请求。</p><p><code>BGSAVE</code>命令会派生一个子进程，由子进程生成 RDB 文件，父进程继续处理请求。</p><p>RDB 文件载入的工作是在服务器启动时自动执行的。</p><p>因为 AOF 文件的更新频率通常比 RDB 文件高，所以如果服务器开启了 AOF 持久化，会优先载入 AOF 文件。</p><h4 id="SAVE-命令执行时服务器的状态"><a href="#SAVE-命令执行时服务器的状态" class="headerlink" title="SAVE 命令执行时服务器的状态"></a>SAVE 命令执行时服务器的状态</h4><p>服务器处于阻塞状态。</p><h4 id="BGSAVE-命令执行时服务器的状态"><a href="#BGSAVE-命令执行时服务器的状态" class="headerlink" title="BGSAVE 命令执行时服务器的状态"></a>BGSAVE 命令执行时服务器的状态</h4><ol><li>客户端发送的 SAVE 命令会被拒绝。</li><li>客户端发送的 BGSAVE 命令也会被拒绝。</li><li>BGREWRITEAOF 和 BGSAVE 不能同时进行。</li></ol><h4 id="RDB-载入时服务器的状态"><a href="#RDB-载入时服务器的状态" class="headerlink" title="RDB 载入时服务器的状态"></a>RDB 载入时服务器的状态</h4><p>服务器处于阻塞状态。</p><h3 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h3><p>Redis 允许用户通过设置保存条件，让服务器每隔一段时间自动执行一次 BGSAVE 命令。</p><p>可以设置多个保存条件，只要有一个满足条件，即可执行 BGSAVE 命令。</p><h4 id="设置保存条件"><a href="#设置保存条件" class="headerlink" title="设置保存条件"></a>设置保存条件</h4><p>服务器在900秒内，至少对数据库进行了1次修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br></pre></td></tr></table></figure><h3 id="RDB-文件结构"><a href="#RDB-文件结构" class="headerlink" title="RDB 文件结构"></a>RDB 文件结构</h3><p><img src="http://picbed.jianghs.com/RDB_file_structure.png" alt="RDB"></p><ul><li>REDIS：程序载入时快速检查是否时 RDB 文件。</li><li>db_version：4个字节，记录 RDB 文件版本号。</li><li>databases：包含零个或者任意多个数据库。</li><li>EOF：标志着 RDB 文件正文内容的结束。</li><li>check_sum：校验和，由上述4个信息计算而得。</li></ul><h4 id="databases"><a href="#databases" class="headerlink" title="databases"></a>databases</h4><p>一个 RDB 文件的 databases 部分可以保存任意多个非空数据库。</p><p><img src="http://picbed.jianghs.com/RDB_databases.png" alt="RDB-databases"></p><ul><li>SELECTDB：表明接下来读入的将是一个数据库号码。</li><li>db_number：记录的是数据库号码。</li><li>key_value_pairs：保存了数据库所有的键值对数据。</li></ul><h4 id="key-value-pairs"><a href="#key-value-pairs" class="headerlink" title="key_value_pairs"></a>key_value_pairs</h4><p>RDB 文件中的每个 key_value_pairs 部分都保存了一个或以上数量的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存。</p><ul><li>TYPE 记录了 value 的类型。</li><li>key 总是一个字符串对象。</li><li>根据 TYPE 类型不同，以及保存内容长度不同，保存 value 的结构和长度也会有所不同。</li></ul><p><img src="http://picbed.jianghs.com/key_value_without_expire.png" alt="key_value"></p><ul><li>EXPIRETIME_MS 表示接下来是过期时间</li><li>ms 表示时间戳。</li></ul><p><img src="http://picbed.jianghs.com/key_value_with_expire.png" alt="key_value_expire"></p><h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><table><thead><tr><th>TYPE</th><th>value</th></tr></thead><tbody><tr><td>REDIS_RDB_TYPE_STRING</td><td>字符串对象</td></tr><tr><td>REDIS_RDB_TYPE_LIST</td><td>列表对象</td></tr><tr><td>REDIS_RDB_TYPE_SET</td><td>集合对象</td></tr><tr><td>REDIS_RDB_TYPE_HASH</td><td>哈希表对象</td></tr><tr><td>REDIS_RDB_TYPE_ZSET</td><td>有序集合对象</td></tr><tr><td>REDIS_RDB_TYPE_INTSET</td><td>INTSET 编码的集合</td></tr><tr><td>REDIS_RDB_TYPE_LIST_ZIPLIST</td><td>压缩列表对象</td></tr><tr><td>REDIS_RDB_TYPE_HASH_ZIPLIST</td><td>压缩列表对象</td></tr><tr><td>REDIS_RDB_TYPE_ZSET_ZIPLIST</td><td>压缩列表对象</td></tr></tbody></table><h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><p>通过保存 Redis 服务器所执行的写命令来记录数据库状态。</p><h3 id="AOF-持久化的实现"><a href="#AOF-持久化的实现" class="headerlink" title="AOF 持久化的实现"></a>AOF 持久化的实现</h3><ol><li>命令追加-append</li><li>文件写入</li><li>文件同步-sync</li></ol><h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>AOF 持久化功能打开时， 服务器执行完一个写命令时，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾。</p><h4 id="AOF-文件的写入与同步"><a href="#AOF-文件的写入与同步" class="headerlink" title="AOF 文件的写入与同步"></a>AOF 文件的写入与同步</h4><p><code>flushAppendOnlyFile()</code> 将 aof_buf 缓冲区的内容写入和保存到 AOF 文件。</p><p><code>flushAppendOnlyFile()</code> 行为由服务器配置的 appendfsync 选项的值决定。</p><table><thead><tr><th>appendfsync</th><th>flushAppendOnlyFile函数的行为</th><th>效率</th><th>安全性</th></tr></thead><tbody><tr><td>always</td><td>将 aof_buf 缓冲区的所有内容写入并同步到 AOF 文件</td><td>低</td><td>高，只丢失一个事件循环数据</td></tr><tr><td>everysec（默认）</td><td>将 aof_buf 缓冲区的所有内容写入到 AOF 文件，如果上次同步 AOF 文件的时间距离现在超过一秒，那么在此对 AOF 文件同步，并且这个同步由一个线程专门执行</td><td>高</td><td>只丢失一秒钟命令数据</td></tr><tr><td>no</td><td>将 aof_buf 缓冲区的所有内容写入到 AOF 文件，但并不对 AOF 文件进行同步，何时同步由操作系统决定</td><td>最高</td><td>丢失上次同步之后的所有命令数据</td></tr></tbody></table><h3 id="AOF-文件的载入和数据还原"><a href="#AOF-文件的载入和数据还原" class="headerlink" title="AOF 文件的载入和数据还原"></a>AOF 文件的载入和数据还原</h3><p><img src="http://picbed.jianghs.com/AOF_LOAD.png" alt="AOF_LOAD"></p><h3 id="AOF-的重写"><a href="#AOF-的重写" class="headerlink" title="AOF 的重写"></a>AOF 的重写</h3><p>为了解决 AOF 文件体积膨胀问题。</p><p>通过该功能，Redis 服务器可以创建一个新的 AOF 文件代替现有的 AOF 文件，新旧文件包含的命令数据一样，但是新的文件不会包含任何浪费空间的冗余命令。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>首先从数据库读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。</p><h4 id="后台重写"><a href="#后台重写" class="headerlink" title="后台重写"></a>后台重写</h4><p>AOF 重写在子进程执行。</p><ol><li>子进程重写期间，不影响父进程执行命令。</li><li>子进程带有父进程的数据副本，是有子进程而不是线程，可以避免在锁的情况下，保证数据的安全性。</li></ol><p>为了解决父子进程数据不一致的情况，Redis 设置了一个 AOF 重写缓冲区。这个缓冲区在服务器创建子进程后开始使用，当 Redis 服务器执行完一个写命令之后，会同时将这个命令发给 AOF 缓冲区和 AOF 重写缓冲区。</p><p>子进程执行 AOF 重写期间，服务器进程执行一下三个工作：</p><ol><li>执行客户端发来的命令。</li><li>将执行后的写命令追加到 AOF 缓冲区。</li><li>将执行后的写命令追加到 AOF 重写缓冲区。</li></ol><p>当子进程完成 AOF 重写工作后，会向父进程发送一个信号，父进程收到该信号之后，会执行：</p><ol><li>将 AOF 重写缓冲区的所有内容写入到新的 AOF 文件中，这是 AOF 文件所保存的数据库状态和服务器当前状态一致。</li><li>对新的 AOF 文件进行改名，原子地覆盖现有的 AOF 文件，完成新旧两个 AOF 文件替换。</li></ol><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Redis 服务器是一个时间驱动程序</p><ul><li>文件事件</li><li>时间事件</li></ul><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>文件事件处理器使用 I/O 多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p><p>当被监听的套接字准备好执行连接应答（accept）\读取（read）\写入（write）\关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p><h4 id="文件事件处理器的构成"><a href="#文件事件处理器的构成" class="headerlink" title="文件事件处理器的构成"></a>文件事件处理器的构成</h4><ol><li>套接字</li><li>I/O 多路复用程序</li><li>文件事件分派器</li><li>事件处理器</li></ol><p><img src="http://picbed.jianghs.com/file_event_processor.png" alt="file_event_processor"></p><h4 id="I-O-多路复用程序的实现"><a href="#I-O-多路复用程序的实现" class="headerlink" title="I/O 多路复用程序的实现"></a>I/O 多路复用程序的实现</h4><p>通过包装常见的 select\epoll\evport 和 kqueue 这些 I/O 多路复用函数库来实现。</p><h4 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h4><table><thead><tr><th>套接字</th><th>客户端对套接字的操作</th><th>事件类型</th></tr></thead><tbody><tr><td>可读</td><td>wirte</td><td>AE_READABLE</td></tr><tr><td>可读</td><td>close</td><td>AE_READABLE</td></tr><tr><td>可应答</td><td>acceptable</td><td>AE_READABLE</td></tr><tr><td>可写</td><td>read</td><td>AE_WRITABLE</td></tr></tbody></table><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>略</p><h4 id="文件事件的处理器"><a href="#文件事件的处理器" class="headerlink" title="文件事件的处理器"></a>文件事件的处理器</h4><ol><li>连接应答处理器</li><li>命令请求处理器</li><li>命令回复处理器</li></ol><p>客户端和服务器通信过程</p><p><img src="http://picbed.jianghs.com/client_server_connect.png" alt="client_server_connect"></p><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><ol><li>定时事件：指定事件后执行一次。</li><li>周期性事件：每隔指定时间执行一次。</li></ol><p>一个时间事件的组成：</p><ol><li>id: 时间事件全局唯一 ID，从小到大一次排列，新事件的 ID 比旧事件 ID 号大。</li><li>when: 毫秒级时间戳，记录事件到达时间。</li><li>timeProc: 时间处理器，一个函数。</li></ol><p>函数返回值决定是定时事件还是周期性事件。</p><ol><li>如果返回的是 AE_NOMORE，那么事件为定时事件。该事件在到达一次之后就会被删除。</li><li>如果返回的非 AE_NOMORE，那么事件为周期性事件。该事件到达之后，服务器会根据时间处理器返回值设置 when，让这个时间再次到达。</li></ol><h4 id="时间事件实现"><a href="#时间事件实现" class="headerlink" title="时间事件实现"></a>时间事件实现</h4><p>将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，就遍历整个链表，查找所有已达的时间事件，并调用相应的事件处理器。</p><h3 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h3><p><img src="http://picbed.jianghs.com/server_process_under_event.png" alt="server_process_under_event"></p><p>因为时间事件在文件事件之后执行，所以通常时间事件会有延迟的情况。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>Redis 一个服务器可以和多个客户端创建网络连接。</p><p>Redis 服务器状态结构的 clients 属性是一个链表，保存了所有与服务器连接的客户端状态。</p><h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><ul><li>通用属性</li><li>和特定功能相关的属性</li></ul><h4 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h4><ul><li>fd 等于-1：伪客户端，源于 AOF 文件或者 Lua 脚本，而非来自网络。</li><li>fd 大于-1: 普通客户端。</li></ul><h4 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h4><p>默认情况 name 属性为空，可手动设置。</p><h4 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h4><p>flags 记录了客户端的角色，以及客户端目前所处的状态。</p><p>可以是单个标志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags = &lt;flag&gt;</span><br></pre></td></tr></table></figure><p>可以是多个标志的二进制或</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags = &lt;flag1&gt; | &lt;flag2&gt; | ...</span><br></pre></td></tr></table></figure><h4 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a>输入缓冲区</h4><p>querybuf 会根据输入内容动态的缩小或扩大，但它的最大不能超过1 GB，否则服务器会关闭这个客户端。</p><h4 id="命令与命令参数"><a href="#命令与命令参数" class="headerlink" title="命令与命令参数"></a>命令与命令参数</h4><p>命令参数和命令参数个数保存在 argv 属性和 argc 属性。</p><p>argv[0] 是要执行的命令，之后的其他项是传给命令的参数。argc 属性负责记录 argv 数组的长度。</p><h4 id="命令的实现函数"><a href="#命令的实现函数" class="headerlink" title="命令的实现函数"></a>命令的实现函数</h4><p>服务器根据 argv[0] 的值，在命令表中查找命令所对应的命令实现函数。将 cmd 指向对应的 redisCommand 结构。</p><p>命令表的查找不区分大小写。</p><h4 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h4><ul><li>固定大小缓冲区：保存长度比较小的回复。</li><li>可变大小缓冲区：保存长度比较大的回复，长字符串，多项组成的列表，包含很多元素的集合。</li></ul><h4 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h4><p>authenticated 记录客户端是否通过身份验证。</p><ul><li>0： 未通过</li><li>1： 通过</li></ul><p>仅在服务器开启了身份验证时使用。</p><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><ul><li>ctime: 创建客户端的时间。</li><li>lastinteraction: 客户端与服务器最后一次互动的时间。</li><li>obuf_soft_limit_reached_time: 输出缓冲区第一次到达软性限制的时间。</li></ul><h3 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h3><h4 id="创建普通客户端"><a href="#创建普通客户端" class="headerlink" title="创建普通客户端"></a>创建普通客户端</h4><p>客户端使用 connect 函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构 clients 链表的末尾。</p><h4 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h4><p>关闭原因很多，不做赘述。</p><h4 id="Lua-脚本的伪客户端"><a href="#Lua-脚本的伪客户端" class="headerlink" title="Lua 脚本的伪客户端"></a>Lua 脚本的伪客户端</h4><p>Redis 服务器初始化时，创建负责执行 Lua 脚本中包含 Redis 命令的伪客户端，并将这个伪客户端关联在服务器状态结构的 lua_client 属性中。</p><p>服务器关闭时，这个客户端才会关闭。</p><h4 id="AOF-文件的伪客户端"><a href="#AOF-文件的伪客户端" class="headerlink" title="AOF 文件的伪客户端"></a>AOF 文件的伪客户端</h4><p>服务器载入文件时，创建伪客户端，载入完毕后，关闭这个客户端。</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h3><h4 id="发送命令请求"><a href="#发送命令请求" class="headerlink" title="发送命令请求"></a>发送命令请求</h4><p>客户端将这个命令转换成协议格式，通过连接到服务器的套接字，将协议格式的命令请求发送给服务器。</p><h4 id="读取命令请求"><a href="#读取命令请求" class="headerlink" title="读取命令请求"></a>读取命令请求</h4><ol><li>读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。</li><li>对输入缓冲区中的命令请求进行分析，提取命令请求中包含的命令参数及命令参数个数，分别保存在客户端状态的 argv 属性和 argc 属性。</li><li>调用命令执行器，执行客户端指定的命令。</li></ol><h4 id="命令执行器（1）-查找命令实现"><a href="#命令执行器（1）-查找命令实现" class="headerlink" title="命令执行器（1）- 查找命令实现"></a>命令执行器（1）- 查找命令实现</h4><p>根据 argv[0] 参数，在命令表中查找参数指定的命令，并将命令保存到客户端状态的 cmd 属性中。</p><h4 id="命令执行器（2）-执行预备操作"><a href="#命令执行器（2）-执行预备操作" class="headerlink" title="命令执行器（2）- 执行预备操作"></a>命令执行器（2）- 执行预备操作</h4><p>预备操作确保命令正确、顺利的执行。</p><h4 id="命令执行器（3）-调用命令的实现函数"><a href="#命令执行器（3）-调用命令的实现函数" class="headerlink" title="命令执行器（3）- 调用命令的实现函数"></a>命令执行器（3）- 调用命令的实现函数</h4><p>命令的实现函数只需要一个指向客户端状态的指针作为参数即可。</p><p>被调用的命令实现函数会执行指定的操作，并产生相应的命令回复，这些回复会保存在客户端状态的输出缓冲区里面，之后实现函数还会为客户端的套接字关联命令回复处理器。</p><h4 id="命令执行器（4）-执行后续工作"><a href="#命令执行器（4）-执行后续工作" class="headerlink" title="命令执行器（4）- 执行后续工作"></a>命令执行器（4）- 执行后续工作</h4><ol><li>添加一条新的慢查询日志</li><li>更新 redisCommand 结构的 millseconds 属性，并将 calls 计数器的值加一。</li><li>AOF 持久化开启，会将刚执行的命令添加到 AOF 缓冲区。</li><li>如果其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。</li></ol><h4 id="将命令回复发送给客户端"><a href="#将命令回复发送给客户端" class="headerlink" title="将命令回复发送给客户端"></a>将命令回复发送给客户端</h4><p>命令回复发送完毕后，回复处理器会清空客户端状态的输出缓冲区。</p><h4 id="客户端接收并打印命令回复"><a href="#客户端接收并打印命令回复" class="headerlink" title="客户端接收并打印命令回复"></a>客户端接收并打印命令回复</h4><p>将回复格式化成人类可读的格式并显示。</p><h3 id="serverCron-函数"><a href="#serverCron-函数" class="headerlink" title="serverCron 函数"></a>serverCron 函数</h3><p>默认每隔100毫秒执行一次。</p><h4 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h4><p>为了减少调用系统时间的次数，采用服务器时间缓存。</p><h4 id="更新-LRU-时钟"><a href="#更新-LRU-时钟" class="headerlink" title="更新 LRU 时钟"></a>更新 LRU 时钟</h4><p>每10秒一次的频率更新一次 LRU 时钟。</p><h4 id="更新服务器每秒执行命令的次数"><a href="#更新服务器每秒执行命令的次数" class="headerlink" title="更新服务器每秒执行命令的次数"></a>更新服务器每秒执行命令的次数</h4><p>traceOperationsPerSeconds 函数会以每100毫秒一次的频率执行，估算并记录服务器在最近一秒钟处理的命令请求的数量。</p><h4 id="更新服务器内存峰值记录"><a href="#更新服务器内存峰值记录" class="headerlink" title="更新服务器内存峰值记录"></a>更新服务器内存峰值记录</h4><p>当前使用内存如果比 stat_peak_memory 大，则更新 stat_peak_memory。</p><h4 id="处理-SIGTERM-信号"><a href="#处理-SIGTERM-信号" class="headerlink" title="处理 SIGTERM 信号"></a>处理 SIGTERM 信号</h4><p>服务器启动是会将 SIGTERM 关联处理器 sigtermHandler 函数，这个信号处理器负责在服务器接收到 SIGTERM 信号时，打开服务器状态的 shutdown_asap 标识。</p><p>每次 serverCron 函数运行时，程序都会对 shutdown_asap 标识检查，决定是否关闭服务器。</p><h4 id="管理客户端资源"><a href="#管理客户端资源" class="headerlink" title="管理客户端资源"></a>管理客户端资源</h4><p>serverCron 函数每次执行都会调用 clientCron 函数，clientCron 会进行两个检查：</p><ol><li>如果客户端和服务器之间的连接已超时，那么程序释放这个客户端。</li><li>如果客户端上一次执行命令请求后，输入缓冲区的大小超过了一定长度，释放当前客户端输入缓冲区，并创建一个默认大小的输入缓冲区。</li></ol><h4 id="管理数据库资源"><a href="#管理数据库资源" class="headerlink" title="管理数据库资源"></a>管理数据库资源</h4><p>serverCron 函数每次执行都会调用 databasesCron 函数，这个函数会对服务器一部分数据库检查，删除其中的过期键，并在有需要时，对字典进行收缩。</p><h4 id="执行被延迟的-BGREWRITEAOF"><a href="#执行被延迟的-BGREWRITEAOF" class="headerlink" title="执行被延迟的 BGREWRITEAOF"></a>执行被延迟的 BGREWRITEAOF</h4><p>serverCron 函数每次执行时，函数都会检查 BGSAVE 或者 BGREWRITEAOF 命令是否正在执行，如果都没有执行，并且 aof_rewrite_scheduled 属性为1，那么服务器执行被延迟的 BGREWRITEAOF。</p><h4 id="检查持久化操作的运行状态"><a href="#检查持久化操作的运行状态" class="headerlink" title="检查持久化操作的运行状态"></a>检查持久化操作的运行状态</h4><p>serverCron 函数每次执行时，函数会检查 rdb_child_pid 和 aof_child_pid 两个属性的值，检查子进程是否有信号发来。</p><h4 id="将-AOF-缓冲区中的内容写入-AOF-文件"><a href="#将-AOF-缓冲区中的内容写入-AOF-文件" class="headerlink" title="将 AOF 缓冲区中的内容写入 AOF 文件"></a>将 AOF 缓冲区中的内容写入 AOF 文件</h4><p>serverCron 函数每次执行时，函数将 AOF 缓冲区中的内容写入 AOF 文件。</p><h4 id="关闭异步客户端"><a href="#关闭异步客户端" class="headerlink" title="关闭异步客户端"></a>关闭异步客户端</h4><p>关闭输出缓冲区超过限制的客户端。</p><h4 id="增加-cronloops-计数器值"><a href="#增加-cronloops-计数器值" class="headerlink" title="增加 cronloops 计数器值"></a>增加 cronloops 计数器值</h4><p>记录 serverCron 执行的次数。</p><h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><h4 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h4><p>创建一个 struct redisServer 类型的实例变量 server 座位服务器的状态，并为结构中的各个属性设置默认值。</p><h4 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h4><p>通过给定参数或者指定配置文件来修改服务器的默认配置。</p><h4 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h4><p>初始化服务器中除了命令表之外的其他数据结构。</p><h4 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h4><ul><li>如果启用 AOF 持久化功能，服务器使用 AOF 文件来还原数据库状态。</li><li>否则用 RDB 文件还原数据库状态。</li></ul><h4 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h4><p>开始执行服务器的事件循环。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h2&gt;&lt;h3 id=&quot;服务器中的数据库&quot;&gt;&lt;a href=&quot;#服务器中的数据库&quot; class=&quot;headerlink&quot; title=&quot;服务器中的
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>JVM-垃圾收集器与内存收集策略</title>
    <link href="http://yoursite.com/2019/07/22/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E6%94%B6%E9%9B%86%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2019/07/22/JVM-垃圾收集器与内存收集策略/</id>
    <published>2019-07-22T05:36:22.000Z</published>
    <updated>2020-03-21T03:35:55.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。垃圾收集器关注的是堆中的内存。</p><h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>缺点:很难解决对象之间互相循环引用的问题。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过一系列的称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（ Reference Chain ），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p><p>Java 中可以作为 GC Roots 的对象包括以下:</p><ol><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI (本地方法)引用的对象</li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>无论使用何种算法，垃圾回收都和“引用”有关。</p><p>jdk 1.2之前：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。</p><p>jdk 1.2之后：</p><ol><li>强引用(Strong)</li><li>软引用(Soft)</li><li>弱引用(Weak)</li><li>虚引用(Phantom)</li></ol><h3 id="对象逃脱被被回收的过程"><a href="#对象逃脱被被回收的过程" class="headerlink" title="对象逃脱被被回收的过程"></a>对象逃脱被被回收的过程</h3><ol><li>可达性分析发现与 GC Roots 没有引用链，进行第一次标记并进行筛选，条件为此对象是否有必要执行 finalize() 方法。</li><li>如果没有重写 finalize() 方法或者虚拟机已经执行过该方法，则认为没有必要执行。</li><li>如果判定为有必要执行，这个对象会被放到一个 F-Quene 对列中，由虚拟机自建立一个低优先级的 Finalizer 线程执行。虚拟机会触发这个线程执行，但并不保证等待它执行完成。</li><li>GC 会对队列中的对象进行一次小规模标记。如果对象可以在 finalize() 方法中与引用链中的任意对象建立联系，就会移除出“被回收集合”。</li></ol><p>备注: finalize()方法不建议使用。</p><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><ol><li><p>废弃常量</p><p> 常量没有被其他地方引用，则可以被回收。</p></li><li><p>无用的类</p><ul><li>该类的所有实例均被回收。</li><li>加载该类的 ClassLoader 已被回收</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li></ol><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>分为标记和清除两个阶段，首先标记待回收的对象，标记完成后统一回收。</p><p>缺点:</p><ol><li>效率问题</li><li>空间问题，产生大量不连续的内存空间碎片。</li></ol><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>优点：效率高</p><p>缺点：将内存缩小为原来的一半</p><p>一般采用此算法来回收新生代。现代虚拟机不是1:1划分，分为一块较大的 Eden 区和两块较小的 Survivor 区。</p><p>如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>分为标记和整理两个阶段，标记和上述一致，整理是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>根据对象存活周期的不同，将内存分为几块。Java 堆一般分为新生代和老年代。新生代采用复制算法，老年代采用标记清除或者标记整理算法。</p><h2 id="HotSpot-算法"><a href="#HotSpot-算法" class="headerlink" title="HotSpot 算法"></a>HotSpot 算法</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><ol><li>根节点主要在全局性引用和执行上下文中，方法区空间很大时，逐个查询效率很低。</li><li>GC 停顿，使用 OopMap</li></ol><h3 id="安全点-程序执行时通过安全点判断"><a href="#安全点-程序执行时通过安全点判断" class="headerlink" title="安全点-程序执行时通过安全点判断"></a>安全点-程序执行时通过安全点判断</h3><ol><li>以是否具有让程序长时间执行的特征为标准，“长时间”最明显的特征就是指令序列复用，如方法调用、循环跳转、异常跳转。</li><li><p>如何在GC发生时让线程跑到最近的安全点上在停顿下来？</p><ul><li>抢先式中断，几乎没有虚拟机选择。</li><li><p>主动式中断</p><p>当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。</p></li></ul></li><li>安全区域-程序不执行时通过安全区域判断<br>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</li></ol><h2 id="HotSpot-垃圾收集器"><a href="#HotSpot-垃圾收集器" class="headerlink" title="HotSpot 垃圾收集器"></a>HotSpot 垃圾收集器</h2><p><img src="http://picbed.jianghs.com/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="hotspot"></p><h3 id="Serial-收集器-新生代"><a href="#Serial-收集器-新生代" class="headerlink" title="Serial 收集器-新生代"></a>Serial 收集器-新生代</h3><ul><li>单线程</li><li>进行垃圾收集时必须暂停其他线程。</li><li>简单高效，适合运行在 Client 模式下的虚拟机。</li></ul><h3 id="ParNew-收集器-新生代"><a href="#ParNew-收集器-新生代" class="headerlink" title="ParNew 收集器-新生代"></a>ParNew 收集器-新生代</h3><ul><li>Serial 收集器的多线程版本</li><li>server 模式下虚拟机新生代垃圾收集的首选</li><li>与 CMS 收集器搭配使用</li></ul><h3 id="Parallel-Scavenge-新生代"><a href="#Parallel-Scavenge-新生代" class="headerlink" title="Parallel Scavenge-新生代"></a>Parallel Scavenge-新生代</h3><ul><li>使用复制算法，并且是并行的多线程收集器。</li><li>适合后台运算不需要多交互的任务。</li><li>吞吐量优先</li><li>自适应调节</li></ul><h3 id="Serial-Old-老年代"><a href="#Serial-Old-老年代" class="headerlink" title="Serial Old-老年代"></a>Serial Old-老年代</h3><ul><li>单线程，使用标记-整理算法的收集器</li><li>Client 模式下使用</li><li><p>如果在 Server 模式下</p><p>在 JDK 1.5以及之前的版本中与 Parallel Scavenge 收集器搭配使用。</p></li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ul><h3 id="Parallel-Old-老年代"><a href="#Parallel-Old-老年代" class="headerlink" title="Parallel Old-老年代"></a>Parallel Old-老年代</h3><ul><li>Parallel Scavenge 老年代版本。</li><li>多线程</li><li>标记-整理算法</li><li>吞吐量优先</li></ul><h3 id="CMS-收集器-老年代"><a href="#CMS-收集器-老年代" class="headerlink" title="CMS 收集器-老年代"></a>CMS 收集器-老年代</h3><ul><li>基于标记-清除算法</li><li><p>步骤：</p><p>初始标记、并发标记、重新标记、并发清除</p></li><li>优点：并发收集、低停顿</li><li>缺点：对 CPU 资源非常敏感、无法处理浮动垃圾、产生大量空间碎片</li></ul><h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><ul><li>特点：<ol><li>并行与并发</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿</li></ol></li></ul><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ol><li>对象优先在 Eden 分配</li><li><p>大对象直接进入老年代</p><p> 大对象：需要大量连续内存空间的java对象，典型如很大的字符串或者数组。</p><p> 虚拟机提供了一个 <code>-XX:PretenureSizeThreshold</code> 参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制(新生代采用复制算法收集内存)。</p></li><li><p>长期存活的对象将进入老年代</p><p> 虚拟机给每个对象定义了一个对象年龄（Age）计数器。</p><p> 如果对象在Eden出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为1。</p><p> 对象在 Survivor 区中每“熬过”一次 Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。</p></li><li><p>动态对象年龄判定</p><p> 虚拟机并不是永远地要求对象的年龄必须达到了 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</p></li><li><p>空间分配担保</p><p> Minor GC 之前</p><ol><li><p>如果老年代最大可用连续内存空间＞新生代所有对象总和，Minor GC 确保安全。</p></li><li><p>否则，检查 HandlePromotionFailure 是否允许担保失败。</p></li><li>如果不允许，进行一次 Full GC。</li><li>如果允许，检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果是则尝试进行一次 Minor GC，否则进行一次 Full GC。</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-内存区域</title>
    <link href="http://yoursite.com/2019/07/22/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/07/22/JVM-内存区域/</id>
    <published>2019-07-22T02:54:38.000Z</published>
    <updated>2020-03-21T03:36:04.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-技术体系"><a href="#Java-技术体系" class="headerlink" title="Java 技术体系"></a>Java 技术体系</h2><ol><li>Java 程序设计语言</li><li>各个硬件平台的 Java 虚拟机</li><li>Class 文件格式</li><li>Java API 类库</li><li>来自商业机构和开源社区的第三方 Java 类库</li></ol><p>其中1、2、4项合称为JDK</p><p><img src="http://picbed.jianghs.com/JDK.JPG" alt="JDK 结构"></p><h2 id="自动内存管理机制"><a href="#自动内存管理机制" class="headerlink" title="自动内存管理机制"></a>自动内存管理机制</h2><h3 id="运行时内存区域"><a href="#运行时内存区域" class="headerlink" title="运行时内存区域"></a>运行时内存区域</h3><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>方法区</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ol><li>当前线程所执行的字节码的行号指示器。</li><li>每个线程都有独立的计数器，各个线程的之间的计数器互不影响，独立存储。“线程私有”内存。</li><li>如果线程执行的是一个 Java 方法，该计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是 Native 方法，这个计数器值则为空。</li><li>此区域是唯一一个在 Java 虚拟机规范中没有规定任务 OutOfMemoryError 情况的区域。</li></ol><h4 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h4><ol><li>线程私有</li><li>Java 方法执行的内存模型</li><li>方法执行的同时创建一个栈帧，存储:局部变量表、操作数栈、动态链接、方法出口等。</li><li>每个方法从创建直至调用完成，对应栈帧在虚拟机栈的入栈到出栈。</li><li>局部变量表:基本数据类型、对象引用和 returnAddress 类型，64位 long 和 double 类型占2个空间，其他类型占用1个空间。</li><li>2个异常: StackOverFlow 和 OutOfMemory</li></ol><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><ol><li>本地方法执行的内存模型</li><li>部分虚拟机将虚拟机栈和本地方法栈合二为一。</li><li>也会抛出两个异常。</li></ol><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ol><li>内存管理中最大的一块</li><li>所有线程共享，虚拟机启动时创建。</li><li>存放实例对象、数组。</li><li>是垃圾回收的主要区域，有时也被称为”GC”堆。</li><li>堆物理上可以不是连续的内存空间，只需要逻辑上连续即可。</li></ol><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ol><li>所有线程共享</li><li>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译产生的代码等。</li><li>对应 HotSpot 虚拟机永久代。</li><li>可以选择固定或者可扩展内存。</li><li>可以选择不进行垃圾收集。</li></ol><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ol><li>方法区的一部分</li><li>存放编译期产生的各种字面量和符号引用，类加载时进入方法区的运行时常量池存放。</li><li>动态性，运行期间也可能将新的常量放入池中。</li></ol><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><ol><li>不是 Java 内存管理的一部分</li><li>注意所有内存之和超过物理总内存。</li></ol><h2 id="HotSpot-虚拟机探秘"><a href="#HotSpot-虚拟机探秘" class="headerlink" title="HotSpot 虚拟机探秘"></a>HotSpot 虚拟机探秘</h2><p>讨论 HotSpot 虚拟机在 Java 堆中对象分配、布局、访问全过程。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><ol><li>检查 new 指令参数能否在常量池定位到一个符号引用，并且检查这个符号引用对应的类是否已经被加载、解析和初始化过。</li><li>如果没有，则执行类加载过程。此时已经确定了需分配的内存大小。</li><li><p>为新生对象分配内存</p><ul><li><p>分配方式:</p><ul><li>内存绝对规整，指针碰撞</li><li>内存不是连续的，空闲列表</li></ul><p>选取哪种分配方式由内存是否规整决定，而内存是否规整由垃圾回收器是否带走压缩整理功能决定。</p></li><li>解决线程安全<ul><li>对分配内存动作进行同步处理:CAS 加失败重试</li><li>内存分配动作按照线程划分在不同区域进行，即每个线程在堆中划分一个本地线程分配缓冲 TLAB (本地线程分配缓冲)</li></ul></li></ul></li><li><p>将分配到的内存初始化为零值。</p><p>保证了对象实例在 Java 代码中可以不用初始化。</p></li><li><p>对对象进行必要设置</p><p>将设置的信息放在对象的对象头中</p></li><li>执行 init 方法</li></ol><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><ul><li><p>对象头</p><ol><li><p>对象自身运行时数据（哈希锁、 GC 分代年龄、锁状态），被称为 “Mark Word”。  </p><p>极小的空间存储尽量多的数据。</p></li><li><p>类型指针<br>对象指向类元数据的指针，不是所有虚拟机都必须在对象数据中保留类型指针。如果是数组，还必须记录数组长度。</p></li></ol></li><li><p>实例数据</p><p>对象存储的真正有效信息，代码中所定义的各种字段信息。存储顺序受虚拟机分配策略和字段在源码中的定义顺序影响。</p></li><li><p>对齐填充</p><p>占位符作用</p></li></ul><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java 程序通过栈上的 reference 数据操作堆上的具体对象。</p><h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>Java 堆中划分出一块区域作为句柄池，reference 存储的就是句柄的地址，句柄中包含的是对象具体实例数据和类型数据各自的具体地址信息。</p><p><img src="http://picbed.jianghs.com/JVM-%E5%8F%A5%E6%9F%84.jpeg" alt="句柄"></p><p>优点:<br>reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p><h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>Java 堆需考虑如何放置访问对象类型数据信息，reference 中存储的直接就是对象地址。</p><p><img src="http://picbed.jianghs.com/JVM-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.jpeg" alt="直接指针"></p><p>优点:<br>速度更快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java-技术体系&quot;&gt;&lt;a href=&quot;#Java-技术体系&quot; class=&quot;headerlink&quot; title=&quot;Java 技术体系&quot;&gt;&lt;/a&gt;Java 技术体系&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Java 程序设计语言&lt;/li&gt;
&lt;li&gt;各个硬件平台的 Java 虚拟
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Redis 数据结构与对象</title>
    <link href="http://yoursite.com/2019/07/20/Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/07/20/Redis-数据结构与对象/</id>
    <published>2019-07-20T13:55:09.000Z</published>
    <updated>2020-03-21T03:39:27.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h2><h3 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li>len : buf 数组已使用字节数量</li><li>free : buf 数组未使用字节数量</li><li>buf[] : 用于保存字符串</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>常数复杂度获取字符串长度。<br>O(1)的时间复杂度</li><li>杜绝缓冲区溢出。<br>当 SDS API 对 SDS 进行修改时，API 会先检查空间是否满足修改的需求。如果不满足 API 会自动扩展空间，然后执行实际修改。</li><li>减少修改字符串长度所需的内存重分配次数。<br>通过未使用空间解除了字符串长度和底层数组长度的关联。<br>空间预分配：用于优化 SDS 字符串增长。当 SDS 的 API 对一个 SDS 进行修改，并且需要对 SDS 进行空间扩展的时候，程序不进会为 SDS 分配修改所必须要的空间，还会分配额外的未使用空间。<br>惰性空间：由于优化 SDS 字符串缩短。当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节的数量记录起来，并等待将来使用。</li><li>二进制安全。</li><li>兼容部分 C 字符串函数。</li></ol><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h4><p>链表节点结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup) (<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*<span class="built_in">free</span>) (<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match) (<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>由 list 结构和 listNode 结构组成的链表</p><p><img src="http://picbed.jianghs.com/redis-list.png" alt="list"></p><p>特点：</p><ol><li>双端</li><li>无环</li><li>带表头指针和表尾指针</li><li>带链表长度计数器</li><li>多态：链表可以存放各种类型的值。</li></ol><h3 id="字典结构"><a href="#字典结构" class="headerlink" title="字典结构"></a>字典结构</h3><p>又称符号表、关联数组、映射，用于保存键值对。</p><p>底层使用哈希表实现，一个哈希表有多个哈希节点，每个哈希节点保存了字典中的一个键值对。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值，= size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下一个哈希节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p><code>*next</code> 可以将多个哈希值相同的键值对连接在一起。</p><p><img src="http://picbed.jianghs.com/%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="hashtable"></p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为-1</span></span><br><span class="line">    in trehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type 属性是一个指向 dictType 结构的指针，每个 dicType 保存了用于操作特定类型键值对的函数。</p><p>privdata 属性则保存了需要传递给特定函数的可选参数。</p><p>ht 属性是包含两个项的数组，字典只使用 ht[0] 哈希表，ht[1] 哈希表只会在对 ht[0] 哈希表 rehash 时使用。</p><p><img src="http://picbed.jianghs.com/dict.png" alt="dict"></p><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>Redis 计算哈希值和索引值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用字典设置的哈希函数计算出键对应的哈希值</span><br><span class="line">hash = dict -&gt; type -&gt; hashFunction(key)</span><br><span class="line"># 使用哈希表的 sizemask 和哈希值计算出索引值</span><br><span class="line">index = hash &amp; dict -&gt; ht[x].sizemask</span><br></pre></td></tr></table></figure><h4 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h4><p>使用链地址法，每个哈希表节点都有一个 next 指针。</p><p>程序将新节点添加到链表的表头位置。</p><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>扩展或收缩哈希表的工作由 rehash（重新散列）完成。</p><ol><li>为字典的 ht[1] 哈希表分配空间，大小取决于要执行的操作，以及 ht[0] 当前包含的键值对。</li><li>将保存在 ht[0] 上的所有键值对 rehash 到 ht[1] 上。</li><li>迁移后，释放 ht[0]，将 ht[1] 设置成 ht[0], 并在 ht[1] 创建一个空白哈希表。</li></ol><h4 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h4><p>采用分而治之的方式，将 rehash 键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新上，避免了集中式 rehash 带来的庞大计算量。</p><p>渐进式 rehash 期间，删除、查找、更新会在两个哈希表上进行，插入只会在 ht[1] 上进行。</p><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><h4 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h4><p>跳跃表是一种有序数据结构。是有序集合键的底层实现之一。Redis 只在两个地方用到了跳跃表，一个实现有序集合键，另一个在集群节点中用作内部数据结构。</p><p>跳跃表包括一个 zskiplist 和 若干个 zskiplistNode。</p><p><img src="http://picbed.jianghs.com/skiplist.png" alt="skiplist"></p><p>zskiplist 结构包含</p><ul><li>header : 指向跳跃表的表头节点。</li><li>tail : 指向跳跃表的表尾节点。</li><li>level : 记录跳跃表中层数最大的节点的层数（表头节点除外）。</li><li>length : 记录跳跃表目前包含的节点的数量（表头节点除外）。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line"><span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">structz skiplistNode *header, *tail;</span><br><span class="line"><span class="comment">// 表中节点的数量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line"><span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line"><span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>zskiplistNode 结构包含：</p><ul><li>level : L1\L2\L3…，每个层有两个属性，前进指针和跨度，1-32的随机数。</li><li>后退指针 : BW 表示后退指针。</li><li>分值 : 跳跃表中各个节点按照分值从小到大排列。</li><li>成员对象 : o1\o2\o3…</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p>前进指针用于遍历，跨度用于计算排位。</p><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><h4 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h4><p>可以保存类型为 int16_t、int32_t 或者 int64_t 的整数值，并且保证集合中不出现重复元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"><span class="comment">// 编码方式</span></span><br><span class="line"><span class="keyword">uint32_t</span> encoding;</span><br><span class="line"><span class="comment">// 集合包含的元素数量</span></span><br><span class="line"><span class="keyword">uint32_t</span> length;</span><br><span class="line"><span class="comment">// 保存元素的数组</span></span><br><span class="line"><span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p><code>contents[]</code> 每项按值的大小从小到大排列，且不包含重复项。</p><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>升级步骤：</p><ol><li>根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将数组现有元素转换成与新元素相同的类型，并将转换后的元素放置在正确的位上，保持有序。</li><li>将新元素添加到底层数组。</li></ol><p>好处：</p><ol><li>提升灵活性</li><li>节约内存</li></ol><h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><p>不支持降级。</p><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表是为了节约内存而设计的。是由一系列特殊编码的连续内存组成的顺序性数据结构。</p><h4 id="压缩列表的组成"><a href="#压缩列表的组成" class="headerlink" title="压缩列表的组成"></a>压缩列表的组成</h4><p>一个压缩列表由任意多个节点组成，每个节点可以保存一个字节数组或者一个整数值。</p><ol><li>zlbytes：记录整个压缩列表占用的内存字节数。</li><li>zltail：记录压缩列表表尾距离压缩列表的起始地址有多少字节。</li><li>zllen：记录了压缩列表包含的节点数量。</li><li>entryX：各个节点。</li><li>zlend：标记压缩列表末端。</li></ol><p><img src="http://picbed.jianghs.com/ziplist.png" alt="ziplist"></p><h4 id="压缩列表节点"><a href="#压缩列表节点" class="headerlink" title="压缩列表节点"></a>压缩列表节点</h4><p>可以保存一个字节数组或者整数值。</p><ol><li>previous_entry_length：前一个节点的长度。</li><li>encoding：记录 content 属性保存的数据类型和长度。</li><li>content：保存节点的值。</li></ol><h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><p>连锁更新的最坏复杂度是O(n2)。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>Redis 没有直接使用上述数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统。</p><ul><li>字符串对象</li><li>列表对象</li><li>哈希对象</li><li>集合对象</li><li>有序集合对象</li></ul><h4 id="对象的类型和编码"><a href="#对象的类型和编码" class="headerlink" title="对象的类型和编码"></a>对象的类型和编码</h4><p>每个对象的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObjec</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type : <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding : <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象的类型如下：</p><table><thead><tr><th>类型常量</th><th>对象的名称</th></tr></thead><tbody><tr><td>REDIS_STRING</td><td>字符串常量</td></tr><tr><td>REDIS_LIST</td><td>列表常量</td></tr><tr><td>REDIS_HASH</td><td>哈希常量</td></tr><tr><td>REDIS_SET</td><td>集合常量</td></tr><tr><td>REDIS_ZSET</td><td>有序集合常量</td></tr></tbody></table><p>对于 Redis 数据库保存的键值来说。键总是字符串对象，值可能是字符串对象、列表对象、哈希对象、集合对象或有序集合对象。</p><p>对象的编码</p><table><thead><tr><th>编码常量</th><th>编码所对应的底层数据结构</th></tr></thead><tbody><tr><td>REDIS_ENCODING_INT</td><td>long 型整数</td></tr><tr><td>REDIS_ENCODING_EMBSTR</td><td>embstr 编码的简单动态字符串</td></tr><tr><td>REDIS_ENCODING_RAW</td><td>简单动态字符串</td></tr><tr><td>REDIS_ENCODING_HT</td><td>字典</td></tr><tr><td>REDIS_ENCODING_LINKEDLIST</td><td>双端链表</td></tr><tr><td>REDIS_ENCODING_ZIPLIST</td><td>压缩列表</td></tr><tr><td>REDIS_ENCODING_INTSET</td><td>整数集合</td></tr><tr><td>REDIS_ENCODING_SKIPLIST</td><td>跳跃表和字典</td></tr></tbody></table><p>每个类型的对象至少使用了两种不同的编码。</p><p>Redis 可以根据不同的场景来为同一对象设置不同的编码，从而优化对象在某一场景的效率。</p><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>字符串对象的编码可以用 int\raw\embstr。</p><ol><li><p>一个字符串对象保存的是整数值，并且这个整数可以用 long 类型表示，则用 int 类型表示。</p></li><li><p>embstr 专门用于优化短字符串，字符串长度下于等于32个字节。</p></li></ol><table><thead><tr><th>类型</th><th>内存分配次数</th><th>内存释放次数</th><th>内存空间</th></tr></thead><tbody><tr><td>raw</td><td>2</td><td>2</td><td>分两次创建</td></tr><tr><td>embstr</td><td>1</td><td>1</td><td>一块连续的内存空间</td></tr></tbody></table><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><p>列表对象的编码可以是 ziplist 或 linkedlist。</p><ol><li><p>ziplist 底层使用压缩列表实现。</p><p>使用 ziplist 的条件：</p><ul><li><p>列表对象保存的所有字符串元素的长度都小于64字节。</p></li><li><p>列表对象保存的元素数量小于512个。</p><p>如果有一个条件不满足则使用 linkedlist。</p></li></ul></li><li><p>linkedlist 底层使用双向链表实现。</p></li></ol><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><p>哈希对象的编码可以是 ziplist 或 hashtable。</p><ol><li><p>ziplist 编码的哈希对象使用压缩列表作为底层实现。</p><ul><li>保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后。</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，后添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ul></li><li><p>hashtable 编码的哈希对象使用字典座位底层实现。</p><ul><li>字典中的每个键都是一个字符串对象，对象中保存了键值对的键。</li><li>字典中的每个值都是一个字符串对象，对象中保存了键值对的值。</li></ul></li><li><p>编码转换</p><ul><li>哈希对象保存的所有键值对的键和值的字符串长度小于64字节。</li><li><p>哈希对象保存的键值对数量小于512个。</p><p>两个条件同时满足时，使用 ziplist 编码。</p></li></ul></li></ol><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>集合对象的编码可以是 intset 或 hashtable。</p><ol><li><p>intset 编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</p></li><li><p>hashtable 编码的集合对象使用字典座位底层实现，字典每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值全部被设置为 NULL。</p></li><li><p>编码转换</p><ul><li>集合对象保存的所有元素都是整数值。</li><li><p>集合对象保存的元素数量小于512个。</p><p>两个条件同时满足时，使用 intset 编码。</p></li></ul></li></ol><h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><p>有序集合的编码可以是 ziplist 或 skiplist。</p><ol><li><p>ziplist 编码的压缩列表对象使用压缩列表座位底层实现，每个元素使用两个紧挨一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个点解保存元素的分值。</p><p> 按照分值从小到大排列。分值较小的元素靠近表头位置，分值较大的元素靠近表尾位置。</p></li><li><p>skiplist 编码的有序集合对象使用 zset 结构作为底层实现，一个 zset 结构包含一个字典和一个跳跃表。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><ul><li>zsl 跳跃表按照分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的 object 属性保存了元素成员，score 属性则保存分值。</li><li>dict 字典为有序集合创建看一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：键保存了元素，值保存了分值。</li></ul></li><li><p>编码转换</p><ul><li>有序集合保存的元素数量小于128个。</li><li><p>有序集合保存的所有元素成员的长度都小于64字节。</p><p>两个条件同时满足时，使用 ziplist 编码。</p></li></ul></li></ol><h4 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h4><ul><li><p>类型检查的实现</p><ol><li>执行特定类型特定命令之前，服务器先检查输入数据库键的值对象是否为执行命令的所需类型，如果是，则执行。</li><li>否则，服务器拒绝执行，并返回一个类型错误。</li></ol></li><li><p>命令多态的实现</p><p>  Redis 除了会根据值对象判断键是否执行命令外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。</p></li></ul><h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>Redis 构建了一个引用计数计数实现的内存回收机制。</p><ol><li>创建一个新对象时，引用计数的值初始化为1。</li><li>当对象被一个新程序使用时，它的引用计数值会加1。</li><li>当对象不再被一个程序使用时，它的引用计数值会减1。</li><li>当对象的引用计数值为0时，对象所占用的内存会被释放。</li></ol><h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><ol><li>将数据库键的值指针指向一个现有的值对象；</li><li>将被共享的值对象的引用计数加1。</li></ol><p>Redis 初始化服务器时，创建0-9999一共一万个整数值。</p><h4 id="对象的空转时间"><a href="#对象的空转时间" class="headerlink" title="对象的空转时间"></a>对象的空转时间</h4><p>lru 属性记录了对象最后一次被命令程序访问的时间，可以用于计算空转时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据结构与对象&quot;&gt;&lt;a href=&quot;#数据结构与对象&quot; class=&quot;headerlink&quot; title=&quot;数据结构与对象&quot;&gt;&lt;/a&gt;数据结构与对象&lt;/h2&gt;&lt;h3 id=&quot;简单动态字符串&quot;&gt;&lt;a href=&quot;#简单动态字符串&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>产品经理培训纪要</title>
    <link href="http://yoursite.com/2019/07/20/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E5%9F%B9%E8%AE%AD%E7%BA%AA%E8%A6%81/"/>
    <id>http://yoursite.com/2019/07/20/产品经理培训纪要/</id>
    <published>2019-07-20T13:41:08.000Z</published>
    <updated>2020-03-16T15:43:15.710Z</updated>
    
    <content type="html"><![CDATA[<h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><p>产品是在<strong>场景</strong>下对于<strong>受众</strong>有<strong>价值</strong>的东西。</p><h4 id="产品的粒度"><a href="#产品的粒度" class="headerlink" title="产品的粒度"></a>产品的粒度</h4><p>从目的出发</p><h4 id="谁定义产品"><a href="#谁定义产品" class="headerlink" title="谁定义产品"></a>谁定义产品</h4><p>由“产品经理”定义，产品定义会因为“产品经理”的认知迭代而发生变化。</p><h3 id="产品经理"><a href="#产品经理" class="headerlink" title="产品经理"></a>产品经理</h3><h4 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h4><ul><li>产品策划 - 资源<ul><li>行业/市场/用户调研</li><li>产品定位</li><li>目标管理</li><li>团队组建</li><li>商业模式</li></ul></li><li>产品设计 - 框架、内容、互动<ul><li>目标结构</li><li>需求分析</li><li>产品架构</li><li>功能设计</li><li>交互设计</li></ul></li><li>产品执行 - 进度、成本、质量<ul><li>项目管理</li><li>资源管理</li><li>团队激励</li><li>质量保证</li><li>后勤保障</li></ul></li></ul><h4 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h4><ul><li>最高效的形态是一人团队。</li><li>引入分工的本质上是能力不足。</li><li>能力不足分为功能缺失和资源缺失。</li><li>前者需要的是专业知识，后者需要的是人力。</li><li>团队形态有中心化和去中心化两种倾向。</li><li>不论哪种形态都需要建立在目标一致和利益共同体的基础上。</li></ul><h4 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h4><ul><li>敏感<ul><li>善于发现问题</li><li>善于剖析解读行为</li><li>人文精神</li><li>对市场有敏感度</li></ul></li><li>认知<ul><li>以“为什么”开始</li><li>有好奇心也有行动</li><li>有明确观点但不故步自封</li><li>博学多才</li></ul></li><li>领导<ul><li>懂得如何建立信任关系</li><li>懂得如何找老师和做别人的老师</li><li>善于激励和调动积极性</li><li>输出反馈和寻求反馈</li></ul></li><li>决策<ul><li>善于系统性思考和化繁为简</li><li>敢于且善于做判断</li><li>理性平衡风险和机会</li><li>数据驱动</li></ul></li></ul><h3 id="产品过程"><a href="#产品过程" class="headerlink" title="产品过程"></a>产品过程</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>做准备、定目标</p><ul><li>组建团队、定义角色、确定资源</li><li>基于现象提出一个待解决问题</li><li>设定长期目标即最终理想状态</li></ul><h4 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h4><p>拆解目标，找到最重要的那个</p><ul><li>如果我们最后失败了最优可能的原因有哪些（必要条件）</li><li>把原因转化成目标并排序</li></ul><h4 id="概念设计"><a href="#概念设计" class="headerlink" title="概念设计"></a>概念设计</h4><p>明确场景和用例</p><ul><li>定义开始和结局</li><li>演绎中间过程（营造真实产品场景）</li></ul><h4 id="产品原型"><a href="#产品原型" class="headerlink" title="产品原型"></a>产品原型</h4><p>提出并验证解决方案</p><ul><li>可证伪</li><li>不要花时间为没有选择的方案做原型</li><li>只关注用户可反馈的部分</li></ul><h4 id="产品策略"><a href="#产品策略" class="headerlink" title="产品策略"></a>产品策略</h4><p>评估和迭代</p><ul><li>定义质量指标</li><li>发现优化点并提出策略</li></ul><h3 id="产品增长"><a href="#产品增长" class="headerlink" title="产品增长"></a>产品增长</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;产品&quot;&gt;&lt;a href=&quot;#产品&quot; class=&quot;headerlink&quot; title=&quot;产品&quot;&gt;&lt;/a&gt;产品&lt;/h3&gt;&lt;p&gt;产品是在&lt;strong&gt;场景&lt;/strong&gt;下对于&lt;strong&gt;受众&lt;/strong&gt;有&lt;strong&gt;价值&lt;/strong&gt;的东西。&lt;
      
    
    </summary>
    
      <category term="work" scheme="http://yoursite.com/categories/work/"/>
    
    
      <category term="PM" scheme="http://yoursite.com/tags/PM/"/>
    
  </entry>
  
  <entry>
    <title>后端中的 Spring</title>
    <link href="http://yoursite.com/2019/07/09/%E5%90%8E%E7%AB%AF%E4%B8%AD%E7%9A%84-Spring/"/>
    <id>http://yoursite.com/2019/07/09/后端中的-Spring/</id>
    <published>2019-07-09T15:10:11.000Z</published>
    <updated>2020-03-16T15:43:15.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-与-JDBC"><a href="#Spring-与-JDBC" class="headerlink" title="Spring 与 JDBC"></a>Spring 与 JDBC</h2><h3 id="Spring-的数据访问哲学"><a href="#Spring-的数据访问哲学" class="headerlink" title="Spring 的数据访问哲学"></a>Spring 的数据访问哲学</h3><p>数据访问功能的组件称为数据访问对象 DAO 或者 Repository。</p><h4 id="数据访问的异常体系"><a href="#数据访问的异常体系" class="headerlink" title="数据访问的异常体系"></a>数据访问的异常体系</h4><p>Spring 提供的平台无关的持久化异常。解决了两个问题：</p><ul><li>解决 JDBC 异常过于简单</li><li>解决了类似了 Hibernate 异常体系其本身独有的问题，即平台无关性。</li></ul><h4 id="数据访问模板化"><a href="#数据访问模板化" class="headerlink" title="数据访问模板化"></a>数据访问模板化</h4><p>模板方法将过程中与特定实现相关的部分委托给接口，而这个接口的不同实现定义了过程中的具体行为。</p><p>Spring 将数据访问过程中固定的和可变的部分划分为：模板和回调。</p><ol><li>模板：事务控制、资源管理、处理异常</li><li>回调：语句、绑定参数、整理结果集</li></ol><h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><ol><li>通过 JDBC 驱动程序定义的数据源</li><li>通过 JNDI 查找的数据源</li><li>连接池的数据源</li></ol><h4 id="使用-JNDI-数据源"><a href="#使用-JNDI-数据源" class="headerlink" title="使用 JNDI 数据源"></a>使用 JNDI 数据源</h4><p>优点：</p><ol><li>数据源独立于应用程序管理。</li><li>应用服务器管理的数据源通常以池的方式组织，具备更好的性能。</li><li>支持系统管理员对其进行热切换。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JndiObjectFactoryBean <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JndiObjectFactoryBean jndiObjectFactoryBean = <span class="keyword">new</span> JndiObjectFactoryBean();</span><br><span class="line">    jndiObjectFactoryBean.setJndiName(<span class="string">"jdbc/xxx"</span>);</span><br><span class="line">    jndiObjectFactoryBean.setResourceRef(<span class="keyword">true</span>);</span><br><span class="line">    jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class);</span><br><span class="line">    <span class="keyword">return</span> jndiObjectFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用数据源连接池"><a href="#使用数据源连接池" class="headerlink" title="使用数据源连接池"></a>使用数据源连接池</h4><ol><li>Apache Common DBCP</li><li>c3p0</li><li>BoneCP</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BasicDataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BasicDataSource dataSource = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">    dataSource.setDriverClassName(<span class="string">"org.h2.Driver"</span>);</span><br><span class="line">    dataSource.setUrl(<span class="string">"jdbc:h2:tcp://localhost/~/spitter"</span>);</span><br><span class="line">    dataSource.setUsername(<span class="string">"jianghs"</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">"jianghs"</span>);</span><br><span class="line">    dataSource.setInitialSize(<span class="number">5</span>);</span><br><span class="line">    dataSource.setMaxActive(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于-JDBC-的数据源"><a href="#基于-JDBC-的数据源" class="headerlink" title="基于 JDBC 的数据源"></a>基于 JDBC 的数据源</h4><p>不推荐用在生产环境。</p><ul><li>DriverManagerDataSource：每个连接请求都会返回一个新建的连接，未池化。</li><li>SimpleDriverDataSource：与 DriverManagerDataSource 类似，解决特定环境下的类加载问题。</li><li>SingleConnectionDataSource：每个连接请求都会返回同一个连接，可以视为只有一个连接的池。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceJdbc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DriverManagerDataSource driverManagerDataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    driverManagerDataSource.setDriverClassName(<span class="string">"org.h2.Driver"</span>);</span><br><span class="line">    driverManagerDataSource.setUrl(<span class="string">"jdbc:h2:tcp://localhost/~/spitter"</span>);</span><br><span class="line">    driverManagerDataSource.setUsername(<span class="string">"jianghs"</span>);</span><br><span class="line">    driverManagerDataSource.setPassword(<span class="string">"jianghs"</span>);</span><br><span class="line">    <span class="keyword">return</span> driverManagerDataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用嵌入式数据源"><a href="#使用嵌入式数据源" class="headerlink" title="使用嵌入式数据源"></a>使用嵌入式数据源</h4><p>适用于开发和测试环境。</p><ul><li>H2</li><li>Apache Derby</li></ul><h4 id="使用-profile-选择数据源"><a href="#使用-profile-选择数据源" class="headerlink" title="使用 profile 选择数据源"></a>使用 profile 选择数据源</h4><p>参见 《Spring 的核心》章节。</p><h3 id="在-Spring-中使用-JDBC"><a href="#在-Spring-中使用-JDBC" class="headerlink" title="在 Spring 中使用 JDBC"></a>在 Spring 中使用 JDBC</h3><p>使用 JdbcTemplate 来插入数据，实例略。</p><h2 id="使用对象-关系映射持久化数据"><a href="#使用对象-关系映射持久化数据" class="headerlink" title="使用对象-关系映射持久化数据"></a>使用对象-关系映射持久化数据</h2><h3 id="集成-Hibernate"><a href="#集成-Hibernate" class="headerlink" title="集成 Hibernate"></a>集成 Hibernate</h3><h3 id="Spring-与-Java-持久化-API"><a href="#Spring-与-Java-持久化-API" class="headerlink" title="Spring 与 Java 持久化 API"></a>Spring 与 Java 持久化 API</h3><h3 id="借助-Spring-Data-实现自动化的-JPA-Repository"><a href="#借助-Spring-Data-实现自动化的-JPA-Repository" class="headerlink" title="借助 Spring Data 实现自动化的 JPA Repository"></a>借助 Spring Data 实现自动化的 JPA Repository</h3><h2 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h2><h3 id="启用对缓存的支持"><a href="#启用对缓存的支持" class="headerlink" title="启用对缓存的支持"></a>启用对缓存的支持</h3><p>TODO</p><h3 id="为方法添加注解以支持缓存"><a href="#为方法添加注解以支持缓存" class="headerlink" title="为方法添加注解以支持缓存"></a>为方法添加注解以支持缓存</h3><p>TODO</p><h3 id="使用-XML-声明缓存"><a href="#使用-XML-声明缓存" class="headerlink" title="使用 XML 声明缓存"></a>使用 XML 声明缓存</h3><p>略</p><h2 id="使用-NoSQL-数据库"><a href="#使用-NoSQL-数据库" class="headerlink" title="使用 NoSQL 数据库"></a>使用 NoSQL 数据库</h2><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>略</p><h3 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h3><p>略</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-与-JDBC&quot;&gt;&lt;a href=&quot;#Spring-与-JDBC&quot; class=&quot;headerlink&quot; title=&quot;Spring 与 JDBC&quot;&gt;&lt;/a&gt;Spring 与 JDBC&lt;/h2&gt;&lt;h3 id=&quot;Spring-的数据访问哲学&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 协议简介</title>
    <link href="http://yoursite.com/2019/07/08/HTTP-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/07/08/HTTP-协议简介/</id>
    <published>2019-07-08T15:55:27.000Z</published>
    <updated>2019-07-08T16:05:58.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="了解-Web-及网络基础"><a href="#了解-Web-及网络基础" class="headerlink" title="了解 Web 及网络基础"></a>了解 Web 及网络基础</h2><h2 id="简单的-HTTP-协议"><a href="#简单的-HTTP-协议" class="headerlink" title="简单的 HTTP 协议"></a>简单的 HTTP 协议</h2><h2 id="HTTP-报文内的-HTTP-信息"><a href="#HTTP-报文内的-HTTP-信息" class="headerlink" title="HTTP 报文内的 HTTP 信息"></a>HTTP 报文内的 HTTP 信息</h2><h2 id="返回结果的状态码"><a href="#返回结果的状态码" class="headerlink" title="返回结果的状态码"></a>返回结果的状态码</h2><h2 id="与-HTTP-协作的-Web-服务器"><a href="#与-HTTP-协作的-Web-服务器" class="headerlink" title="与 HTTP 协作的 Web 服务器"></a>与 HTTP 协作的 Web 服务器</h2><h2 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h2><h2 id="确保-Web-安全的-HTTPS"><a href="#确保-Web-安全的-HTTPS" class="headerlink" title="确保 Web 安全的 HTTPS"></a>确保 Web 安全的 HTTPS</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;了解-Web-及网络基础&quot;&gt;&lt;a href=&quot;#了解-Web-及网络基础&quot; class=&quot;headerlink&quot; title=&quot;了解 Web 及网络基础&quot;&gt;&lt;/a&gt;了解 Web 及网络基础&lt;/h2&gt;&lt;h2 id=&quot;简单的-HTTP-协议&quot;&gt;&lt;a href=&quot;#简单
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Web 中的 Spring</title>
    <link href="http://yoursite.com/2019/07/01/Web-%E4%B8%AD%E7%9A%84-Spring/"/>
    <id>http://yoursite.com/2019/07/01/Web-中的-Spring/</id>
    <published>2019-07-01T14:08:13.000Z</published>
    <updated>2019-07-08T15:24:38.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构建-Spring-Web-应用"><a href="#构建-Spring-Web-应用" class="headerlink" title="构建 Spring Web 应用"></a>构建 Spring Web 应用</h2><p>Spring MVC 基于模型-视图-控制器模式实现。</p><h3 id="Spring-MVC-原理"><a href="#Spring-MVC-原理" class="headerlink" title="Spring MVC 原理"></a>Spring MVC 原理</h3><ol><li><p><code>DispatcherServlet</code> 作为前端控制器，将请求发送给 Spring MVC 的控制器(<code>controller</code>)。通过查询一个或者多个处理器映射（<code>handler mapping</code>）来确定请求的控制器。</p></li><li><p><code>controller</code> 处理完逻辑后，将模型数据打包，并标识出渲染输出的视图名，返回给 <code>DispatcherServlet</code>。</p></li><li><p><code>DispatcherServlet</code> 使用视图解析器(<code>view resolver</code>)来将逻辑视图名匹配为一个特定的视图实现。</p></li><li><p>最后一步就是视图的实现。</p></li></ol><h3 id="搭建-Spring-MVC"><a href="#搭建-Spring-MVC" class="headerlink" title="搭建 Spring MVC"></a>搭建 Spring MVC</h3><h4 id="配置-DispatcherServlet"><a href="#配置-DispatcherServlet" class="headerlink" title="配置 DispatcherServlet"></a>配置 DispatcherServlet</h4><p>继承 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 类</p><ol><li>getServletMappings()：将一个或者多个路径映射到 <code>DispatcherServlet</code>。</li><li>getRootConfigClasses()：该方法获取的配置类由 <code>ContextLoaderListener</code> 生成，对应的 bean 通常是驱动应用后端的中间层和数据层组件。</li><li>getServletConfigClasses()：该方法获取的配置类由 <code>DispatcherServlet</code> 生成。</li></ol><h4 id="启用-Spring-MVC"><a href="#启用-Spring-MVC" class="headerlink" title="启用 Spring MVC"></a>启用 Spring MVC</h4><p>通过注解 <code>@EnableWebMvc</code> 启用。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol><li>视图解析器</li><li>静态资源处理</li></ol><h3 id="编写基本控制器"><a href="#编写基本控制器" class="headerlink" title="编写基本控制器"></a>编写基本控制器</h3><p><code>@Controller</code> 声明是个控制器，作用于方法或者类。</p><p><code>@RequestMapping(value=&quot;&quot;, method=xxx)</code> value 指定请求的路径，method 细化了 HTTP 请求处理的方法，可以作用于方法或者类。</p><h4 id="传递模型数据到视图中"><a href="#传递模型数据到视图中" class="headerlink" title="传递模型数据到视图中"></a>传递模型数据到视图中</h4><ol><li>Model\Map key 值的自动推断</li><li>返回视图的自动推断</li></ol><h4 id="请求输入的输入"><a href="#请求输入的输入" class="headerlink" title="请求输入的输入"></a>请求输入的输入</h4><ol><li>查询参数：<code>@RequestParam(&quot;xxx&quot;)</code></li><li>表单参数：展现表单、处理表单提交的数据、校验表单</li><li>路径变量：通过添加占位符<code>{</code> xx <code>}</code> 实现。<code>@PathVaraiable(&quot;xx&quot;)</code> 表明占位符不论传什么值都会到 xx 参数。</li></ol><h2 id="渲染-Web-视图"><a href="#渲染-Web-视图" class="headerlink" title="渲染 Web 视图"></a>渲染 Web 视图</h2><h3 id="创建-JSP-视图"><a href="#创建-JSP-视图" class="headerlink" title="创建 JSP 视图"></a>创建 JSP 视图</h3><h4 id="配置使用于-JSP-的视图解析器"><a href="#配置使用于-JSP-的视图解析器" class="headerlink" title="配置使用于 JSP 的视图解析器"></a>配置使用于 JSP 的视图解析器</h4><p>推荐使用 <code>InternalResourceViewResolver</code> 来创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InternalResourceViewResolver resolver = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">    resolver.setPrefix(<span class="string">"/WEB-INF/views"</span>);</span><br><span class="line">    resolver.setSuffix(<span class="string">".jsp"</span>);</span><br><span class="line">    resolver.setExposeContextBeansAsAttributes(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析-JSTL-视图"><a href="#解析-JSTL-视图" class="headerlink" title="解析 JSTL 视图"></a>解析 JSTL 视图</h4><p>只需设置它的 viewClass 属性即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolver.setViewClass(JstlView.class);</span><br></pre></td></tr></table></figure><h4 id="使用-Spring-的-JSP-库"><a href="#使用-Spring-的-JSP-库" class="headerlink" title="使用 Spring 的 JSP 库"></a>使用 Spring 的 JSP 库</h4><ol><li>渲染 HTML 表单标签</li><li>工具类标签</li></ol><h3 id="Apache-Titles-视图定义布局"><a href="#Apache-Titles-视图定义布局" class="headerlink" title="Apache Titles 视图定义布局"></a>Apache Titles 视图定义布局</h3><p>略</p><h3 id="使用-Thymeleaf"><a href="#使用-Thymeleaf" class="headerlink" title="使用 Thymeleaf"></a>使用 Thymeleaf</h3><h4 id="配置-Thymeleaf-视图解析器"><a href="#配置-Thymeleaf-视图解析器" class="headerlink" title="配置 Thymeleaf 视图解析器"></a>配置 Thymeleaf 视图解析器</h4><ol><li>模板解析器</li><li>模板引擎</li><li>视图解析器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringResourceTemplateResolver <span class="title">templateResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SpringResourceTemplateResolver templateResolver = <span class="keyword">new</span> SpringResourceTemplateResolver();</span><br><span class="line">    templateResolver.setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    templateResolver.setPrefix(<span class="string">"/WEB-INF/templates/"</span>);</span><br><span class="line">    templateResolver.setSuffix(<span class="string">".html"</span>);</span><br><span class="line">    <span class="comment">// HTML is the default value, added here for the sake of clarity.</span></span><br><span class="line">    templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">    <span class="comment">// Template cache is true by default. Set to false if you want</span></span><br><span class="line">    <span class="comment">// templates to be automatically updated when modified.</span></span><br><span class="line">    templateResolver.setCacheable(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> templateResolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringTemplateEngine <span class="title">templateEngine</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// SpringTemplateEngine automatically applies SpringStandardDialect and</span></span><br><span class="line">    <span class="comment">// enables Spring's own MessageSource message resolution mechanisms.</span></span><br><span class="line">    SpringTemplateEngine templateEngine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">    templateEngine.setTemplateResolver(templateResolver());</span><br><span class="line">    <span class="comment">// Enabling the SpringEL compiler with Spring 4.2.4 or newer can</span></span><br><span class="line">    <span class="comment">// speed up execution in most scenarios, but might be incompatible</span></span><br><span class="line">    <span class="comment">// with specific cases when expressions in one template are reused</span></span><br><span class="line">    <span class="comment">// across different data types, so this flag is "false" by default</span></span><br><span class="line">    <span class="comment">// for safer backwards compatibility.</span></span><br><span class="line">    templateEngine.setEnableSpringELCompiler(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> templateEngine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ThymeleafViewResolver <span class="title">viewResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ThymeleafViewResolver viewResolver = <span class="keyword">new</span> ThymeleafViewResolver();</span><br><span class="line">    viewResolver.setTemplateEngine(templateEngine());</span><br><span class="line">    <span class="keyword">return</span> viewResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义-Thymeleaf-模板"><a href="#定义-Thymeleaf-模板" class="headerlink" title="定义 Thymeleaf 模板"></a>定义 Thymeleaf 模板</h4><p>使用自定义的命名空间 <code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code></p><p>Thymeleaf 方言 <code>@{}</code></p><h2 id="Spring-MVC-的高级技术"><a href="#Spring-MVC-的高级技术" class="headerlink" title="Spring MVC 的高级技术"></a>Spring MVC 的高级技术</h2><h3 id="Spring-MVC-的替代方案"><a href="#Spring-MVC-的替代方案" class="headerlink" title="Spring MVC 的替代方案"></a>Spring MVC 的替代方案</h3><h4 id="自定义-DispatcherServlet-配置"><a href="#自定义-DispatcherServlet-配置" class="headerlink" title="自定义 DispatcherServlet 配置"></a>自定义 DispatcherServlet 配置</h4><p>通过重载 <code>customizeRegistration()</code> 方法，我们可以进行额外配置。</p><h4 id="添加其他的-Servlet-和-Filter"><a href="#添加其他的-Servlet-和-Filter" class="headerlink" title="添加其他的 Servlet 和 Filter"></a>添加其他的 Servlet 和 Filter</h4><p>定义任意数量的初始化器类。最简单的方法是实现 Spring 的 <code>WebApplicationInitializer</code> 接口。</p><h4 id="在-web-xml-中声明-DispatcherServlet"><a href="#在-web-xml-中声明-DispatcherServlet" class="headerlink" title="在 web.xml 中声明 DispatcherServlet"></a>在 web.xml 中声明 DispatcherServlet</h4><p>略</p><h3 id="处理文件上传"><a href="#处理文件上传" class="headerlink" title="处理文件上传"></a>处理文件上传</h3><h4 id="配置-multipart-解析器"><a href="#配置-multipart-解析器" class="headerlink" title="配置 multipart 解析器"></a>配置 multipart 解析器</h4><p>委托给 Spring 中的 <code>MultipartResolver</code> 策略接口的实现。</p><ol><li><code>CommonMultipartResolver</code>：使用 Jakarta Commons FileUpload 解析 multipart 请求。</li><li><code>StandardServletMultipartResolver</code>：依赖于 Servlet 3.0 对 multipart 请求的支持。</li></ol><h4 id="处理-multipart-请求"><a href="#处理-multipart-请求" class="headerlink" title="处理 multipart 请求"></a>处理 multipart 请求</h4><p><code>@RequestPart</code>：作用于控制器方法参数上。</p><h4 id="接受-MultipartFile"><a href="#接受-MultipartFile" class="headerlink" title="接受 MultipartFile"></a>接受 MultipartFile</h4><p><code>MultipartFile</code> 接口</p><h3 id="在控制器处理异常"><a href="#在控制器处理异常" class="headerlink" title="在控制器处理异常"></a>在控制器处理异常</h3><ol><li>特定的 Spring 异常将自动映射为特定的 HTTP 状态码</li><li>异常上添加 <code>@ResponseStatus</code> 注解，从而将其映射为某一个 HTTP 状态码</li><li>在方法上添加 <code>@ExceptionHandler</code> 注解，使其用来处理异常。</li></ol><h4 id="将异常映射为-HTTP-状态码"><a href="#将异常映射为-HTTP-状态码" class="headerlink" title="将异常映射为 HTTP 状态码"></a>将异常映射为 HTTP 状态码</h4><p>默认情况下，Spring 会将自身的一些异常自动转换成合适的状态码。</p><p><code>@ResponseStatus</code> 注解将异常映射为 HTTP 状态码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus</span>(value = HttpStatus.NOT_FOUND, reason = <span class="string">"spittle not found"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpittleNotFoundException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写异常处理的方法"><a href="#编写异常处理的方法" class="headerlink" title="编写异常处理的方法"></a>编写异常处理的方法</h4><p><code>@ExceptionHandler</code> 当抛出指定的异常时，将会委托该方法处理。它能处理同一个控制器所有方法抛出的这类异常。</p><h3 id="为控制器添加通知"><a href="#为控制器添加通知" class="headerlink" title="为控制器添加通知"></a>为控制器添加通知</h3><p><code>@ControllerAdvice</code> 修饰控制器通知类，这个类会包含一个或者多个如下类型</p><ul><li><code>@ExceptionHandler</code> 注解标注的方法</li><li><code>@InitBinder</code> 注解标注的方法</li><li><code>@ModelAttribute</code> 注解标注的方法</li></ul><h3 id="跨重定向请求传输数据"><a href="#跨重定向请求传输数据" class="headerlink" title="跨重定向请求传输数据"></a>跨重定向请求传输数据</h3><p>对于重定向来说，模型并不能用来传递数据。可以通过其他方案处理：</p><ul><li>使用 URL 模板以路径变量和 / 或查询参数的形式传递数据</li><li>使用 flash 属性发送数据</li></ul><h4 id="通过-URL-模板进行重定向"><a href="#通过-URL-模板进行重定向" class="headerlink" title="通过 URL 模板进行重定向"></a>通过 URL 模板进行重定向</h4><p>占位符自动填充，所有不安全字符会进行转义。</p><p>如果属性找不到占位符，会自动以查询参数的形式附加到重定向 URL 上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.addAttribute(<span class="string">"name"</span>, xxx.getName());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:/xxx/&#123;name&#125;"</span>;</span><br></pre></td></tr></table></figure><h4 id="使用-flash-属性"><a href="#使用-flash-属性" class="headerlink" title="使用 flash 属性"></a>使用 flash 属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.addFlashAttribute(<span class="string">"xxx"</span>, xxx);</span><br></pre></td></tr></table></figure><p>flash 属性会一直携带这些数据知道下一次请求，才回消失。</p><p>在执行重定向之前，所有的 flash 属性都会复制到会话中。重定向之后，存在会话中的 flash 属性会被取出，并从会话转移到模型中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;构建-Spring-Web-应用&quot;&gt;&lt;a href=&quot;#构建-Spring-Web-应用&quot; class=&quot;headerlink&quot; title=&quot;构建 Spring Web 应用&quot;&gt;&lt;/a&gt;构建 Spring Web 应用&lt;/h2&gt;&lt;p&gt;Spring MVC 基于模
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 的核心</title>
    <link href="http://yoursite.com/2019/06/30/Spring-%E7%9A%84%E6%A0%B8%E5%BF%83/"/>
    <id>http://yoursite.com/2019/06/30/Spring-的核心/</id>
    <published>2019-06-30T06:51:01.000Z</published>
    <updated>2019-06-30T15:56:32.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-核心"><a href="#Spring-核心" class="headerlink" title="Spring 核心"></a>Spring 核心</h2><h3 id="依赖注入（DI）或者控制反转（IoC）"><a href="#依赖注入（DI）或者控制反转（IoC）" class="headerlink" title="依赖注入（DI）或者控制反转（IoC）"></a>依赖注入（DI）或者控制反转（IoC）</h3><p>对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定。对象无需自行创建或者管理它们的依赖关系。</p><p>创建应用组件之间协作的行为通常称为装配。Spring 通常的装配方式：XML、Java 描述。</p><h3 id="面向切面（AOP）"><a href="#面向切面（AOP）" class="headerlink" title="面向切面（AOP）"></a>面向切面（AOP）</h3><p>允许把遍布应用各处的功能分离出来形成可重用的组件。</p><h3 id="Spring-容器"><a href="#Spring-容器" class="headerlink" title="Spring 容器"></a>Spring 容器</h3><h4 id="bean-工厂"><a href="#bean-工厂" class="headerlink" title="bean 工厂"></a>bean 工厂</h4><p>BeanFactory 是最简单的容器，提供最基本的 DI 支持。</p><h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h4><p>基于 BeanFactory 构建，并提供框架级别服务。</p><ul><li>AnnotationConfigApplicationContext</li><li>AnnotationConfigWebApplicationContext</li><li>ClassPathXmlApplicationContext</li><li>FileSystemXmlApplicationContext</li><li>XmlWebApplicationContext</li></ul><h4 id="bean-的生命周期"><a href="#bean-的生命周期" class="headerlink" title="bean 的生命周期"></a>bean 的生命周期</h4><ol><li>实例化</li><li>填充属性</li><li>调用 BeanNameAware 的 setBeanName()方法</li><li>调用 BeanFactoryAware 的 setBeanFactory()方法</li><li>调用 ApplicationContextAware 的 setApplicationContext() 方法</li><li>调用 BeanPostProcessor 的预初始化方法 postProcessBeforeInitialization()</li><li>调用 InitializingBean 的 afterPropertiesSet() 方法</li><li>调用自定义的初始化方法</li><li>调用 BeanPostProcesser 的初始化后方法 postProcessAfterInitialization()</li><li>调用 DisposableBean 的 destory() 方法。</li><li>调用自定义的销毁方法</li></ol><p>1-9步 bean 已经准备就绪，可以被应用程序使用，它们将一直驻留在应用上下文中，直至应用上下文被销毁。</p><h2 id="装配-Bean"><a href="#装配-Bean" class="headerlink" title="装配 Bean"></a>装配 Bean</h2><h3 id="装配的可选方案"><a href="#装配的可选方案" class="headerlink" title="装配的可选方案"></a>装配的可选方案</h3><h4 id="隐式的-bean-发现机制和自动装配"><a href="#隐式的-bean-发现机制和自动装配" class="headerlink" title="隐式的 bean 发现机制和自动装配"></a>隐式的 bean 发现机制和自动装配</h4><ul><li>组件扫描: Spring 会自动发现应用上下文中所创建的 bean.</li><li>自动装配: Spring 自动满足 bean 之间的依赖。</li></ul><p><code>@Component(id)</code> ：表明该类会作为组件类，并告知 Spring 要为这个类创建 bean. id 缺省时，将类名的第一个字母变小写。</p><p><code>@Named(id)</code> ：Java 依赖注入规范，可作为 <code>@Component(id)</code>  的替代方案。</p><p><code>@Configuration</code>：表明该类作为配置类。</p><p><code>@ComponentScan(basepackages=&quot;com.xxx&quot;, &quot;com.yyy&quot;)</code>：这个注解能够在 Spring 中启用组件扫描，默认会扫描与配置类相同的包。<code>basepackages</code> 可以设置多个扫描的基础包。</p><p><code>@Autowired</code>：声明要自动装配。可以设置在构造器、Setter 方法或者其他方法上。</p><h4 id="在-Java-中进行显式配置"><a href="#在-Java-中进行显式配置" class="headerlink" title="在 Java 中进行显式配置"></a>在 Java 中进行显式配置</h4><ol><li>创建配置类</li><li>声明简答的 bean</li><li>借助 JavaConfig 实现注入</li></ol><p><code>@Bean(name=&quot;xxx&quot;)</code>：告诉 Spring 这个方法将要返回一个对象，这个对象要注册为 Spring 应用上下文的 bean. name 可以缺省。</p><h4 id="在-XML-中进行显式配置"><a href="#在-XML-中进行显式配置" class="headerlink" title="在 XML 中进行显式配置"></a>在 XML 中进行显式配置</h4><p>不做介绍</p><h3 id="导入和混合配置"><a href="#导入和混合配置" class="headerlink" title="导入和混合配置"></a>导入和混合配置</h3><h4 id="JavaConfig-中引入-XML-配置"><a href="#JavaConfig-中引入-XML-配置" class="headerlink" title="JavaConfig 中引入 XML 配置"></a>JavaConfig 中引入 XML 配置</h4><p><code>@Import({xxx.class, yyy.class})</code>:引入多个 Java 配置类。</p><p><code>@ImportResource(&quot;classpath:xxx.xml&quot;)</code>:引入 xxx.xml 配置文件。</p><h4 id="在-XML-配置中引入-JavaConfig"><a href="#在-XML-配置中引入-JavaConfig" class="headerlink" title="在 XML 配置中引入 JavaConfig"></a>在 XML 配置中引入 JavaConfig</h4><h2 id="高级装配"><a href="#高级装配" class="headerlink" title="高级装配"></a>高级装配</h2><h3 id="Spring-profile"><a href="#Spring-profile" class="headerlink" title="Spring profile"></a>Spring profile</h3><p><code>@Profile</code>：指定某个 bean 属于哪个 profile</p><h4 id="配置-profile-bean"><a href="#配置-profile-bean" class="headerlink" title="配置 profile bean"></a>配置 profile bean</h4><p>下面的例子为 dev 环境及 prd 环境配置数据源，dev 环境采用内置数据库，prd 正式环境采用 JNDI.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jianghs.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jianghs.model.DataSourceExistsCondition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Conditional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jndi.JndiObjectFactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jianghongsen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>: DataSourceConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span> spring-study</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-06-2317:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span>: Conditional 表明是个条件 bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> javax.sql.DataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> jianghongsen</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2019-06-23 18:08</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"dev"</span>) <span class="comment">// 为 dev profile 装配的 bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">devDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">                .setType(EmbeddedDatabaseType.H2)</span><br><span class="line">                .addScript(<span class="string">""</span>)</span><br><span class="line">                .addScript(<span class="string">""</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"prd"</span>) <span class="comment">// 为 prd profile 装配的 bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">prdDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JndiObjectFactoryBean jndiObjectFactoryBean = <span class="keyword">new</span> JndiObjectFactoryBean();</span><br><span class="line">        jndiObjectFactoryBean.setJndiName(<span class="string">""</span>);</span><br><span class="line">        jndiObjectFactoryBean.setResourceRef(<span class="keyword">true</span>);</span><br><span class="line">        jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class);</span><br><span class="line">        <span class="keyword">return</span> (DataSource)jndiObjectFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="激活-profile"><a href="#激活-profile" class="headerlink" title="激活 profile"></a>激活 profile</h4><ul><li>spring.profiles.active: 激活的 profile</li><li>spring.profiles.default: 默认的 profile</li></ul><p>如果没有设置 <code>spring.profiles.active</code> 属性的话，那么 Spring 将查找 <code>spring.profiles.default</code> 的值。如果均没有设置的话，那就没有激活的 profile.</p><ul><li>作为 DispatcherServlet 的初始化参数；</li><li>作为 Web 应用的上下文参数；</li><li>作为 JNDI 条目；</li><li>作为 环境变量；</li><li>作为 JVM 系统属性；</li><li>在集成测试类上，使用 <code>@ActiveProfiles</code> 注解设置；</li></ul><h3 id="条件化的-bean-声明"><a href="#条件化的-bean-声明" class="headerlink" title="条件化的 bean 声明"></a>条件化的 bean 声明</h3><p><code>@Conditioanl(xxx.class)</code>：可以用到带有 <code>@Bean</code> 注解的方法上。如果给定的条件计算结果为 true，就会创建这个 bean，否则的话，这个 bean 被忽略。</p><p><code>ConditionContext</code> 接口</p><p><code>AnnotatedTypeMetadata</code> 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jianghs.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Condition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jianghongsen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>: DataSourceExistsCondition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span> spring-study</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-06-2318:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceExistsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata)</span> </span>&#123;</span><br><span class="line">        Environment env = conditionContext.getEnvironment();</span><br><span class="line">        <span class="keyword">return</span> env.containsProperty(<span class="string">"magic"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动装配与歧义性"><a href="#自动装配与歧义性" class="headerlink" title="自动装配与歧义性"></a>自动装配与歧义性</h3><p>如果多个 bean 可以匹配结果，这种歧义性会阻碍 Spring 自动装配属性、构造器参数或方法参数。</p><h4 id="标示首选的-bean"><a href="#标示首选的-bean" class="headerlink" title="标示首选的 bean"></a>标示首选的 bean</h4><p><code>@Primary</code>：可以和 <code>@Component</code> 或者 <code>@Bean</code> 搭配使用。</p><h4 id="限定自动装配的-bean"><a href="#限定自动装配的-bean" class="headerlink" title="限定自动装配的 bean"></a>限定自动装配的 bean</h4><p><code>@Qualifier(xxx)</code>：使用限定符的主要方式。</p><h3 id="bean-的作用域"><a href="#bean-的作用域" class="headerlink" title="bean 的作用域"></a>bean 的作用域</h3><ul><li>单例（Singleton）:默认情况，整个应用，只创建一个 bean 的实例。</li><li>原型（Prototype）:每次注入或者通过上下文获取的时候，都会创建一个新的 bean 实例。</li><li>会话（Session）:在 Web 应用中，为每个会话创建一个 bean 实例。</li><li>请求（Request）:在 Web 应用中，为每个请求创建一个 bean 实例。</li></ul><p><code>@Scope(ConfigurableBeanFactory.xxx)</code>：标示作用域范围。</p><h3 id="运行时值注入"><a href="#运行时值注入" class="headerlink" title="运行时值注入"></a>运行时值注入</h3><h4 id="属性占位符"><a href="#属性占位符" class="headerlink" title="属性占位符"></a>属性占位符</h4><p><code>@PropertySource(&quot;classpath:xxx/yyy/app.properties&quot;)</code>：引入资源配置文件</p><p>占位符形式：${…}</p><h4 id="Spring-表达式语言（SpEL）"><a href="#Spring-表达式语言（SpEL）" class="headerlink" title="Spring 表达式语言（SpEL）"></a>Spring 表达式语言（SpEL）</h4><p>形式：#{…}</p><h2 id="面向切面"><a href="#面向切面" class="headerlink" title="面向切面"></a>面向切面</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>AOP 可以实现横向关注点（日志、声明式事务、安全、缓存等）与业务逻辑分离。</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li>通知（Advice）:切面需要完成的工作，定义了切面是什么及何时使用。<ul><li>前置通知（Before）：在目标方法被调用之前调用通知功能。</li><li>后置通知（After）：在目标方法被调用之后调用通知功能。</li><li>返回通知（After-returning）：在目标方法成功执行后调用通知。</li><li>异常通知（After-throwing）：在目标方法抛出异常之后调用通知功能。</li><li>环绕通知（Around）：在目标方法调用前后执行通知功能。</li></ul></li><li>连接点（Join Point）：应用通知的时机。可以是调用方法时、抛出异常时、修改字段时等。</li><li>切点（Pointcut）：切点的定义会匹配通知要织入的一个或者多个连接点。</li><li>切面（Aspect）：通知和切点的结合。通知和切点定义了切面的全部内容-它是什么，在何时和何处完成其功能。</li><li>引入（Introduction）：允许我们向现有的类添加新方法或属性。</li><li>织入（Weaving）：把切面应用到目标对象并创建新的代理对象的过程。<ul><li>编译期：AspectJ</li><li>类加载期：AspectJ</li><li>运行期：SpringAOP</li></ul></li></ul><h4 id="Spring-对-AOP-的支持"><a href="#Spring-对-AOP-的支持" class="headerlink" title="Spring 对 AOP 的支持"></a>Spring 对 AOP 的支持</h4><ul><li>基于代理的经典 Spring AOP;</li><li>纯 POJO 切面;</li><li><code>@AspectJ</code> 注解驱动的切面;</li><li>注入式 AspectJ 切面。</li></ul><p>1、基于代理的经典 Spring AOP 使用 ProxyFactory Bean,过于复杂和笨重。</p><p>2、纯 POJO 切面需要 XML 技术。</p><p>3、<code>@AspectJ</code> 注解驱动的切面，能够不使用 XML 来完成功能。</p><h4 id="关键知识"><a href="#关键知识" class="headerlink" title="关键知识"></a>关键知识</h4><ul><li>Spring 通知是 Java 编写的</li><li>Spring 在运行时通知对象</li><li>Spring 只支持方法级别的连接点</li></ul><h3 id="通过切点来选择连接点"><a href="#通过切点来选择连接点" class="headerlink" title="通过切点来选择连接点"></a>通过切点来选择连接点</h3><p>切点用于准确定位应该在什么地方应用切面的通知。</p><p><code>execution()</code> 指示器是实际执行匹配的。</p><h4 id="编写切点"><a href="#编写切点" class="headerlink" title="编写切点"></a>编写切点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* 包名.类名.方法(..))</span><br></pre></td></tr></table></figure><p><code>*</code> 表明不关心返回类型，<code>..</code> 表明切点要选择任意参数列表的方法。</p><h4 id="在切点中选择-bean"><a href="#在切点中选择-bean" class="headerlink" title="在切点中选择 bean"></a>在切点中选择 bean</h4><p><code>bean()</code> 指示器允许在切点表达式中使用 bean 的 ID 来标识 bean.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* 包名.类名.方法(..)) <span class="function">and <span class="title">bean</span><span class="params">(<span class="string">'aaa'</span>)</span></span></span><br></pre></td></tr></table></figure><p>限定 bean 的 ID 为 aaa.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* 包名.类名.方法(..)) and !bean(<span class="string">'aaa'</span>)</span><br></pre></td></tr></table></figure><p>限定 bean 的 ID 除了 aaa.</p><h3 id="使用注解创建切面"><a href="#使用注解创建切面" class="headerlink" title="使用注解创建切面"></a>使用注解创建切面</h3><p><code>@Aspect</code> 创建切面。</p><p><code>@PointCut</code> 能够在 <code>@Aspect</code> 切面内定义可重用的切点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jianghs.concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jianghongsen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>: Audience</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span> spring-study</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-06-3022:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.jianghs.concert.Performance.perform(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"performance()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"手机静音"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"performance()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeSeats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"就坐"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"performance()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鼓掌"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"performance()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"退款"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@EnableAspectJAutoProxy</code> 启用自动代理功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jianghs.concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jianghongsen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>: ConcertConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span> spring-study</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-06-3022:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcertConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Audience <span class="title">audience</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Audience();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建环绕通知"><a href="#创建环绕通知" class="headerlink" title="创建环绕通知"></a>创建环绕通知</h3><p>一定不能忘了调用 <code>proceed()</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jianghs.concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jianghongsen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>: Audience</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span> spring-study</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-06-3022:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.jianghs.concert.Performance.perform(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"performance()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchPerformance</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"手机静音"</span>);</span><br><span class="line">            System.out.println(<span class="string">"就坐"</span>);</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">            System.out.println(<span class="string">"鼓掌"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"退款"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理通知中的参数"><a href="#处理通知中的参数" class="headerlink" title="处理通知中的参数"></a>处理通知中的参数</h3><p><code>args()</code> 限定符会将参数传递到通知中。</p><h3 id="在-XML-中声明切面"><a href="#在-XML-中声明切面" class="headerlink" title="在 XML 中声明切面"></a>在 XML 中声明切面</h3><p>当无法获得通知类的源码添加注解的时候，需要通过 XML 作为补充。</p><h3 id="注入-AspectJ-切面"><a href="#注入-AspectJ-切面" class="headerlink" title="注入 AspectJ 切面"></a>注入 AspectJ 切面</h3><p>当 Spring AOP 无法满足要求时，需要通过 AspectJ 实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-核心&quot;&gt;&lt;a href=&quot;#Spring-核心&quot; class=&quot;headerlink&quot; title=&quot;Spring 核心&quot;&gt;&lt;/a&gt;Spring 核心&lt;/h2&gt;&lt;h3 id=&quot;依赖注入（DI）或者控制反转（IoC）&quot;&gt;&lt;a href=&quot;#依赖注入（D
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>原码 反码 补码</title>
    <link href="http://yoursite.com/2017/10/31/%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81/"/>
    <id>http://yoursite.com/2017/10/31/原码-反码-补码/</id>
    <published>2017-10-31T00:48:16.000Z</published>
    <updated>2019-07-01T16:41:17.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原码-反码-补码简明介绍"><a href="#原码-反码-补码简明介绍" class="headerlink" title="原码,反码,补码简明介绍"></a>原码,反码,补码简明介绍</h2><h3 id="机器数和真值"><a href="#机器数和真值" class="headerlink" title="机器数和真值"></a>机器数和真值</h3><ul><li>机器数</li></ul><p>一个数在机器中二进制存储的形式。最高位存放符号，正数为0，负数为1。</p><ul><li>真值</li></ul><p>带符号的机器数表示为真值。</p><h3 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h3><ul><li>原码</li></ul><p>符号位加上真值的绝对值。</p><ul><li>反码</li></ul><p>正数的反码是其本身。<br>负数的反码是在其基础上，符号位不变，其余各个位取反。</p><ul><li>补码</li></ul><p>正数的补码就是其本身。<br>负数的补码就是再其原码基础上，符号位不变，其余各位取反，最后加1。</p><p>负数的补码 = 负数的反码 + 1</p><h3 id="为何要使用原码、反码、补码"><a href="#为何要使用原码、反码、补码" class="headerlink" title="为何要使用原码、反码、补码"></a>为何要使用原码、反码、补码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反 = [00000001]补</span><br><span class="line">[-1] = [10000001]原 = [11111110]反 = [11111111]补</span><br></pre></td></tr></table></figure><p>首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p><p>可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?</p><p>首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p><p>于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:</p><p>计算十进制的表达式: 1-1=0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</span><br></pre></td></tr></table></figure><p>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.</p><p>为了解决原码做减法的问题, 出现了反码:</p><p>计算十进制的表达式: 1-1=0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</span><br></pre></td></tr></table></figure><p>发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.</p><p>于是补码的出现, 解决了0的符号以及两个编码的问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</span><br></pre></td></tr></table></figure><p>这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</span><br></pre></td></tr></table></figure><p>-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)</p><p>使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].</p><p>因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原码-反码-补码简明介绍&quot;&gt;&lt;a href=&quot;#原码-反码-补码简明介绍&quot; class=&quot;headerlink&quot; title=&quot;原码,反码,补码简明介绍&quot;&gt;&lt;/a&gt;原码,反码,补码简明介绍&lt;/h2&gt;&lt;h3 id=&quot;机器数和真值&quot;&gt;&lt;a href=&quot;#机器数和真值&quot;
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="Others" scheme="http://yoursite.com/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 基础配置</title>
    <link href="http://yoursite.com/2017/03/16/CentOS6%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/03/16/CentOS6基础配置/</id>
    <published>2017-03-16T05:52:45.000Z</published>
    <updated>2019-07-01T16:40:54.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CentOS基础配置"><a href="#CentOS基础配置" class="headerlink" title="CentOS基础配置"></a>CentOS基础配置</h2><h3 id="下载、安装及配置jdk"><a href="#下载、安装及配置jdk" class="headerlink" title="下载、安装及配置jdk"></a>下载、安装及配置jdk</h3><h4 id="在线下载-jdk"><a href="#在线下载-jdk" class="headerlink" title="在线下载 jdk"></a>在线下载 jdk</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate --no-cookies --header <span class="string">"Cookie: oraclelicense=accept-securebackup-cookie"</span> http://download.oracle.com/otn-pub/java/jdk/8u91-b14/jdk-8u91-linux-x64.rpm</span><br></pre></td></tr></table></figure><h4 id="rpm-安装-jdk"><a href="#rpm-安装-jdk" class="headerlink" title="rpm 安装 jdk"></a>rpm 安装 jdk</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh jdk-8u91-linux-x64.rpm</span><br></pre></td></tr></table></figure><h4 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h4><p>编辑 profile 文件，在文件末尾添加以下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.8.0_121</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=,:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME CLASSPATH PATH</span><br></pre></td></tr></table></figure><h4 id="使-profile-生效"><a href="#使-profile-生效" class="headerlink" title="使 profile 生效"></a>使 profile 生效</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ0xi0lndyippx6f13iwviZ software]<span class="comment"># java -version</span></span><br><span class="line">java version <span class="string">"1.8.0_121"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_121-b13)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)</span><br></pre></td></tr></table></figure><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><ul><li>*** permission denied</li></ul><p>对应文件没有执行权限,修改成可以执行。<br>7：用户可读，可写，可运行<br>5：用户组可读，可写，不可运行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 ***</span><br></pre></td></tr></table></figure><ul><li>Exec format error</li></ul><p>Java 环境变量配置<br>Linux 系统分隔符为英文冒号 ：，而 Windows 系统分隔符为分号 ; ，此处需区分明确。</p><h3 id="下载、安装及配置-TomCat"><a href="#下载、安装及配置-TomCat" class="headerlink" title="下载、安装及配置 TomCat"></a>下载、安装及配置 TomCat</h3><h4 id="下载-TomCat7"><a href="#下载-TomCat7" class="headerlink" title="下载 TomCat7"></a>下载 TomCat7</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ0xi0lndyippx6f13iwviZ software]<span class="comment"># wget http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-7/v7.0.75/bin/apache-tomcat-7.0.75.tar.gz</span></span><br></pre></td></tr></table></figure><h4 id="解压-TomCat7"><a href="#解压-TomCat7" class="headerlink" title="解压 TomCat7"></a>解压 TomCat7</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ0xi0lndyippx6f13iwviZ software]<span class="comment"># tar -zxv -f apache-tomcat-7.0.75.tar.gz</span></span><br></pre></td></tr></table></figure><h4 id="运行-TomCat"><a href="#运行-TomCat" class="headerlink" title="运行 TomCat"></a>运行 TomCat</h4><p>进入 TomCat 安装目录bin文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh</span><br></pre></td></tr></table></figure><h4 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h4><p>编辑rc.local</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ0xi0lndyippx6f13iwviZ rc.d]<span class="comment"># vim /etc/rc.d/rc.local</span></span><br></pre></td></tr></table></figure><p>在末尾加入以下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME = /usr/java/jdk1.8.0_121</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line">/usr/software/apache-tomcat-7.0.75/bin/startup.sh</span><br></pre></td></tr></table></figure><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>将项目打包成 war 包。<br>将 war 包放在 tomcat webapps 目录下即可。</p><h3 id="下载、安装及配置-MySql"><a href="#下载、安装及配置-MySql" class="headerlink" title="下载、安装及配置 MySql"></a>下载、安装及配置 MySql</h3><h4 id="下载及安装"><a href="#下载及安装" class="headerlink" title="下载及安装"></a>下载及安装</h4><p>由于 CentOS 中集成了 MySQL ,我们可以用如下命令查看是否安装了 MySQL 数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@li1600-30 /]<span class="comment"># rpm -qa | grep mysql</span></span><br></pre></td></tr></table></figure><p>如果能查到结果，可以删除后自行安装。<br>如果不删除，启动服务时，提示未识别的服务。<br>经确认需安装 mysql server ,命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure><p>后续再次执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@li1600-30 /]<span class="comment"># service mysqld start</span></span><br><span class="line">Initializing MySQL database:  Installing MySQL system tables...</span><br><span class="line">OK</span><br><span class="line">Filling <span class="built_in">help</span> tables...</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">To start mysqld at boot time you have to copy</span><br><span class="line">support-files/mysql.server to the right place <span class="keyword">for</span> your system</span><br><span class="line"></span><br><span class="line">PLEASE REMEMBER TO SET A PASSWORD FOR THE MySQL root USER !</span><br><span class="line">To <span class="keyword">do</span> so, start the server, <span class="keyword">then</span> issue the following commands:</span><br><span class="line"></span><br><span class="line">/usr/bin/mysqladmin -u root password <span class="string">'new-password'</span></span><br><span class="line">/usr/bin/mysqladmin -u root -h li1600-30.members.linode.com password <span class="string">'new-password'</span></span><br><span class="line"></span><br><span class="line">Alternatively you can run:</span><br><span class="line">/usr/bin/mysql_secure_installation</span><br><span class="line"></span><br><span class="line"><span class="built_in">which</span> will also give you the option of removing the <span class="built_in">test</span></span><br><span class="line">databases and anonymous user created by default.  This is</span><br><span class="line">strongly recommended <span class="keyword">for</span> production servers.</span><br><span class="line"></span><br><span class="line">See the manual <span class="keyword">for</span> more instructions.</span><br><span class="line"></span><br><span class="line">You can start the MySQL daemon with:</span><br><span class="line"><span class="built_in">cd</span> /usr ; /usr/bin/mysqld_safe &amp;</span><br><span class="line"></span><br><span class="line">You can <span class="built_in">test</span> the MySQL daemon with mysql-test-run.pl</span><br><span class="line"><span class="built_in">cd</span> /usr/mysql-test ; perl mysql-test-run.pl</span><br><span class="line"></span><br><span class="line">Please report any problems with the /usr/bin/mysqlbug script!</span><br><span class="line"></span><br><span class="line">                                                           [  OK  ]</span><br><span class="line">Starting mysqld:                                           [  OK  ]</span><br></pre></td></tr></table></figure><h4 id="开机启动设置"><a href="#开机启动设置" class="headerlink" title="开机启动设置"></a>开机启动设置</h4><p>通过如下命令确认mysqld服务是不是开机自动启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@li1600-30 /]<span class="comment"># chkconfig --list | grep mysqld</span></span><br><span class="line">mysqld         0:off 1:off 2:off 3:off 4:off 5:off 6:off</span><br></pre></td></tr></table></figure><p>我们发现 mysqld 并没有开机启动，可以将其设置为开机启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@li1600-30 /]<span class="comment"># chkconfig mysqld on</span></span><br></pre></td></tr></table></figure><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>数据库安装完后只会有一个 root 账号，并且未设置密码。<br>可以通过如下命令设置密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@li1600-30 /]<span class="comment"># mysqladmin -u root password 'root'</span></span><br></pre></td></tr></table></figure><p>现在就可以通过 root 用户登录数据库了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@li1600-30 /]<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password:</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 6</span><br><span class="line">Server version: 5.1.73 Source distribution</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">'\c'</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><h4 id="开启远程登录"><a href="#开启远程登录" class="headerlink" title="开启远程登录"></a>开启远程登录</h4><p>查询 user 表，发现 root 用户对应的 host 只允许本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT User, Password, Host FROM user;</span><br><span class="line">+------+-------------------------------------------+------------------------------+</span><br><span class="line">| User | Password                                  | Host                         |</span><br><span class="line">+------+-------------------------------------------+------------------------------+</span><br><span class="line">| root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | localhost                    |</span><br><span class="line">| root |                                           | li1600-30.members.linode.com |</span><br><span class="line">| root |                                           | 127.0.0.1                    |</span><br><span class="line">|      |                                           | localhost                    |</span><br><span class="line">|      |                                           | li1600-30.members.linode.com |</span><br><span class="line">+------+-------------------------------------------+------------------------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>下面我们添加一个新的 root 用户，密码为空，允许任意 IP 连接，后续刷新缓存，后续即可远程连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">''</span> WITH GRANT OPTION;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT User, Password, Host FROM user;</span><br><span class="line">+------+-------------------------------------------+------------------------------+</span><br><span class="line">| User | Password                                  | Host                         |</span><br><span class="line">+------+-------------------------------------------+------------------------------+</span><br><span class="line">| root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | localhost                    |</span><br><span class="line">| root |                                           | li1600-30.members.linode.com |</span><br><span class="line">| root |                                           | 127.0.0.1                    |</span><br><span class="line">|      |                                           | localhost                    |</span><br><span class="line">|      |                                           | li1600-30.members.linode.com |</span><br><span class="line">| root |                                           | %                            |</span><br><span class="line">+------+-------------------------------------------+------------------------------+</span><br><span class="line">6 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>至此，完成 jdk 安装， tomcat 配置及工程部署， MySQL 数据库配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CentOS基础配置&quot;&gt;&lt;a href=&quot;#CentOS基础配置&quot; class=&quot;headerlink&quot; title=&quot;CentOS基础配置&quot;&gt;&lt;/a&gt;CentOS基础配置&lt;/h2&gt;&lt;h3 id=&quot;下载、安装及配置jdk&quot;&gt;&lt;a href=&quot;#下载、安装及配置jd
      
    
    </summary>
    
      <category term="coding" scheme="http://yoursite.com/categories/coding/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>
