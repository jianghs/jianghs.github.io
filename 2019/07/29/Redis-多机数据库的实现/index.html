<!doctype html>



  


<html class="theme-next mist use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Redis,">





  <link rel="alternate" href="/atom.xml" title="Life Line" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.png?v=5.0.1">






<meta name="description" content="复制通过 SLAVEOF 命令或者设置 slaveof 选项，启动复制功能。 旧版复制功能的实现 同步（SYNC）：将从服务器数据更新至主服务器当前所处的数据状态。 命令传播（command propagate）:在主服务器数据发生修改，导致主从服务器不一致时，让主从服务器回到一致状态。  同步 从服务器向主服务器发送 SYNC 命令。 收到 SYNC 命令的主服务器执行 BGSAVE 命令，在后">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis-多机数据库的实现">
<meta property="og:url" content="http://yoursite.com/2019/07/29/Redis-多机数据库的实现/index.html">
<meta property="og:site_name" content="Life Line">
<meta property="og:description" content="复制通过 SLAVEOF 命令或者设置 slaveof 选项，启动复制功能。 旧版复制功能的实现 同步（SYNC）：将从服务器数据更新至主服务器当前所处的数据状态。 命令传播（command propagate）:在主服务器数据发生修改，导致主从服务器不一致时，让主从服务器回到一致状态。  同步 从服务器向主服务器发送 SYNC 命令。 收到 SYNC 命令的主服务器执行 BGSAVE 命令，在后">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://picbed.jianghs.com/PSYNC_PROCESS.png">
<meta property="og:image" content="http://picbed.jianghs.com/PING.png">
<meta property="og:image" content="http://picbed.jianghs.com/verify.png">
<meta property="og:image" content="http://picbed.jianghs.com/Sentinel-init.png">
<meta property="og:image" content="http://picbed.jianghs.com/excute-client-command.png">
<meta property="og:updated_time" content="2020-03-21T03:38:54.394Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis-多机数据库的实现">
<meta name="twitter:description" content="复制通过 SLAVEOF 命令或者设置 slaveof 选项，启动复制功能。 旧版复制功能的实现 同步（SYNC）：将从服务器数据更新至主服务器当前所处的数据状态。 命令传播（command propagate）:在主服务器数据发生修改，导致主从服务器不一致时，让主从服务器回到一致状态。  同步 从服务器向主服务器发送 SYNC 命令。 收到 SYNC 命令的主服务器执行 BGSAVE 命令，在后">
<meta name="twitter:image" content="http://picbed.jianghs.com/PSYNC_PROCESS.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Redis-多机数据库的实现 | Life Line </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <a href="https://github.com/jianghs/jianghs.github.io" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Life Line</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Constant Dropping Wears Away A Stone</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Redis-多机数据库的实现
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-07-29T15:02:36+08:00" content="2019-07-29">
              2019-07-29
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/coding/" itemprop="url" rel="index">
                    <span itemprop="name">coding</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>通过 <code>SLAVEOF</code> 命令或者设置 slaveof 选项，启动复制功能。</p>
<h3 id="旧版复制功能的实现"><a href="#旧版复制功能的实现" class="headerlink" title="旧版复制功能的实现"></a>旧版复制功能的实现</h3><ul>
<li>同步（SYNC）：将从服务器数据更新至主服务器当前所处的数据状态。</li>
<li>命令传播（command propagate）:在主服务器数据发生修改，导致主从服务器不一致时，让主从服务器回到一致状态。</li>
</ul>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ol>
<li>从服务器向主服务器发送 SYNC 命令。</li>
<li>收到 SYNC 命令的主服务器执行 BGSAVE 命令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有写命令。</li>
<li>当主服务器的 BGSAVE 命令执行完毕时，主服务器会将生成的 RDB 文件发送给从服务器，从服务器接收并载入这个 RDB 文件，将自己的数据库状态更新至主服务器执行 BGSAVE 时的数据库状态。</li>
<li>主服务器将记录在缓冲区的所有写命令发送给从服务器，从服务器执行这些写命令，将数据库状态更新到主服务器数据库当前所处的状态。</li>
</ol>
<h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><p>主服务器对从服务器执行命令传播操作。</p>
<h3 id="旧版复制功能的缺陷"><a href="#旧版复制功能的缺陷" class="headerlink" title="旧版复制功能的缺陷"></a>旧版复制功能的缺陷</h3><p>断线后重新复制，主服务器接收到 SYNC 命令后会将所有的数据生成 RDB 文件，导致效率低下。</p>
<h3 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="headerlink" title="新版复制功能的实现"></a>新版复制功能的实现</h3><p><code>PSYNC</code> 命令具备完整重同步和部分重同步两种模式。</p>
<p>完整重同步用于初次复制情况，与 SYNC 功能一致。</p>
<p>部分重同步用于断线后重新复制的情况，断线后，如果条件允许，只复制断线期间的写命令。</p>
<ol>
<li>从服务器向主服务器发送 PSYNC 命令。</li>
<li>主服务器向从服务器回复 +CONTINUE 回复，表示执行部分重同步。</li>
<li>从服务器接收 +CONTINUE 回复，准备执行部分重同步。</li>
</ol>
<h3 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h3><h4 id="主服务器的复制偏移量和从服务器的复制偏移量"><a href="#主服务器的复制偏移量和从服务器的复制偏移量" class="headerlink" title="主服务器的复制偏移量和从服务器的复制偏移量"></a>主服务器的复制偏移量和从服务器的复制偏移量</h4><ol>
<li>主服务器每次向从服务器传播 N 个字节数据时，就将自己的复制偏移量加 N。</li>
<li>从服务器接收到 N 个字节数据时，就将自己的复制偏移量加 N。</li>
</ol>
<p>如果主从服务器的复制偏移量相等，则数据库状态一致。否则处于不一致的状态。</p>
<h4 id="主服务器的复制积压缓冲区"><a href="#主服务器的复制积压缓冲区" class="headerlink" title="主服务器的复制积压缓冲区"></a>主服务器的复制积压缓冲区</h4><p>复制积压缓冲区是主服务器维护的一个固定长度、先进先出的队列。默认大小 1 MB。</p>
<p>积压缓冲区会记录每个字节对应的偏移量。</p>
<ol>
<li>当主服务器进行命令传播时，不仅会把所有写命令发给所有从服务器，还会将写命令入队到复制积压缓冲区。</li>
<li>主服务器接收到从服务器的 PSYNC 命令后，如果从服务器复制偏移量之后的数据仍然存在于积压缓冲区，那么主服务器会对从服务器执行部分重同步。</li>
<li>否则执行完整重同步。</li>
</ol>
<h4 id="服务器的运行-ID"><a href="#服务器的运行-ID" class="headerlink" title="服务器的运行 ID"></a>服务器的运行 ID</h4><p>从服务器进行初次复制时，主服务器会将自己的服务器 ID 发送给从服务器，从服务器会保存这个 ID。</p>
<p>如果从服务器保存的 ID 与 重新连接的服务器 ID 相同，主服务器可以继续尝试部分重同步。否则进行完整重同步。</p>
<h3 id="PSYNC-命令的实现"><a href="#PSYNC-命令的实现" class="headerlink" title="PSYNC 命令的实现"></a>PSYNC 命令的实现</h3><p><img src="http://picbed.jianghs.com/PSYNC_PROCESS.png" alt="PSYNC 情况"></p>
<h3 id="复制的实现"><a href="#复制的实现" class="headerlink" title="复制的实现"></a>复制的实现</h3><ol>
<li><p>设置主服务器的地址和端口</p>
<p> 从服务器的 redisServer 的 masterhost 属性和 masterport 属性记录以上信息。</p>
</li>
<li><p>建立套接字连接</p>
<p> 从服务器是主服务器的客户端。</p>
</li>
<li><p>发送 PING 命令</p>
<ul>
<li>检查套接字是否读写正常。</li>
<li><p>检查主服务器是否可以正常处理命令请求。</p>
<p><img src="http://picbed.jianghs.com/PING.png" alt="ping"></p>
</li>
</ul>
</li>
<li><p>身份验证</p>
<p> <img src="http://picbed.jianghs.com/verify.png" alt="verify"></p>
</li>
<li><p>发送端口信息</p>
<p> 从服务器向主服务器发送自己的端口信息，主服务器将从服务器的端口记录在 redisClient 中。</p>
</li>
<li><p>进行同步</p>
<p> 从服务器向主服务器发送 PSYNC 命令，执行同步操作。</p>
<p> 执行同步前，只有从服务器是主服务器是客户端，执行同步后，主从服务器互为客户端。</p>
</li>
<li><p>进行命令传播</p>
<p> 完成同步后，主从服务器就会进入命令传播阶段。</p>
</li>
</ol>
<h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>命令传播阶段，从服务器默认每秒一次的频率，向主服务器发送以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK &lt;replication_offset&gt;</span><br></pre></td></tr></table></figure>
<p>作用：</p>
<ul>
<li>检测主从服务器网络连接状态</li>
<li>辅助实现 min-slaves 选项</li>
<li>检测命令丢失</li>
</ul>
<h4 id="检测主从服务器网络连接状态"><a href="#检测主从服务器网络连接状态" class="headerlink" title="检测主从服务器网络连接状态"></a>检测主从服务器网络连接状态</h4><p>如果主服务器一秒内没有收到从服务器发送的命令，认为网络有问题。</p>
<h4 id="辅助实现-min-slaves-选项"><a href="#辅助实现-min-slaves-选项" class="headerlink" title="辅助实现 min-slaves 选项"></a>辅助实现 min-slaves 选项</h4><p>min-salves-to-write 和 min-slaves-max-lag 防止主服务器在不安全的情况下执行写操作。</p>
<h4 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a>检测命令丢失</h4><p>与部分重同步原理类似，区别在于检测命令丢失不是在断线的情况下。</p>
<h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>哨兵解决方案：由一个或者多个 sentinel 实例组成的 sentinel 系统可以监视任意多个主服务器以及这些主服务器属下的所有从服务器。</p>
<h3 id="启动并初始化-Sentinel"><a href="#启动并初始化-Sentinel" class="headerlink" title="启动并初始化 Sentinel"></a>启动并初始化 Sentinel</h3><h4 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h4><p>Sentinel 服务器本质上是一个 Redis 服务器，但是初始化过程不完全一致。</p>
<p><img src="http://picbed.jianghs.com/Sentinel-init.png" alt="Sentinel-init"></p>
<h4 id="将普通-Redis-服务器使用的代码替换成-Sentinel-专用代码"><a href="#将普通-Redis-服务器使用的代码替换成-Sentinel-专用代码" class="headerlink" title="将普通 Redis 服务器使用的代码替换成 Sentinel 专用代码"></a>将普通 Redis 服务器使用的代码替换成 Sentinel 专用代码</h4><p>指定自己的端口和载入自己的命令。</p>
<h4 id="初始化-Sentinel-状态"><a href="#初始化-Sentinel-状态" class="headerlink" title="初始化 Sentinel 状态"></a>初始化 Sentinel 状态</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前纪元，用于实现故障转移</span></span><br><span class="line">  <span class="keyword">unit64_t</span> current_epoch;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存了所有被这个 sentinel 监视的主服务器</span></span><br><span class="line">  <span class="comment">// 字典的键是主服务器的名字</span></span><br><span class="line">  <span class="comment">// 字典的值时指向 sentinelRedisInstance 结构的指针</span></span><br><span class="line">  dict *masters;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否进入 TILT 模式</span></span><br><span class="line">  <span class="keyword">int</span> tilt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 目前正在执行的脚本的数量</span></span><br><span class="line">  <span class="keyword">int</span> running_scripts;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入 TILT 模式的时间</span></span><br><span class="line">  <span class="keyword">mstime_t</span> tilt_start_time;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后一次执行时间处理器的时间</span></span><br><span class="line">  <span class="keyword">mstime_t</span> previous_time;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个 FIFO 队列，包含了所有需要执行的用户脚本</span></span><br><span class="line">  <span class="built_in">list</span> *scripts_queue;</span><br><span class="line">&#125; sentinel;</span><br></pre></td></tr></table></figure>
<h4 id="初始化-Sentinel-状态的-masters-属性"><a href="#初始化-Sentinel-状态的-masters-属性" class="headerlink" title="初始化 Sentinel 状态的 masters 属性"></a>初始化 Sentinel 状态的 masters 属性</h4><ul>
<li>字典的键是被监视的主服务器的名字</li>
<li>字典的值指向被监视主服务器对应的 sentinelRedisInstance 结构</li>
</ul>
<p>每个实例结构代表一被 sentinel 监控的 Redis 服务器实例，这个实例可以是主服务器、从服务器或者另一个 Sentinel。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标识值，记录了实例的类型，以及该实例的当前状态</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例的名字</span></span><br><span class="line">  <span class="comment">// 主服务器的名字由用户在配置文件中设置</span></span><br><span class="line">  <span class="comment">// 从服务器及 Sentinel 的名字由 Sentinel 自动设置</span></span><br><span class="line">  <span class="comment">// 格式为 ip:port</span></span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例的运行 ID</span></span><br><span class="line">  <span class="keyword">char</span> *runid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置纪元，用于实现故障转移</span></span><br><span class="line">  <span class="keyword">uint_64_t</span> config_epoch;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例的地址</span></span><br><span class="line">  sentinelAddr *addr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例无响应多少毫秒后才会被判断为主观下线</span></span><br><span class="line">  <span class="keyword">mstime_t</span> down_after_period;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断客观下线所需的支持投票数量</span></span><br><span class="line">  <span class="keyword">int</span> quorum;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在执行故障转移时，可以同时对新的主服务器进行同步的从服务器数量</span></span><br><span class="line">  <span class="keyword">int</span> parallel_syncs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 刷新故障转移状态的最大时限</span></span><br><span class="line">  <span class="keyword">mstime_t</span> failover_timeout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; sentinelRedisInstance;</span><br></pre></td></tr></table></figure>
<h4 id="创建连向主服务器的网络连接"><a href="#创建连向主服务器的网络连接" class="headerlink" title="创建连向主服务器的网络连接"></a>创建连向主服务器的网络连接</h4><p>创建两个连向主服务器的异步连接：</p>
<ul>
<li>命令连接，用于向主服务器发送命令，并接受命令回复。</li>
<li>订阅连接，用于订阅主服务器的 <em>sentinel</em>:hello 频道。</li>
</ul>
<h3 id="获取主服务器信息"><a href="#获取主服务器信息" class="headerlink" title="获取主服务器信息"></a>获取主服务器信息</h3><p>默认以每十秒一次的频率，通过命令连接向被监视的主服务器发送 INFO 命令，并通过分析 INFO 命令的回复来获取主服务器的当前信息。</p>
<ul>
<li>主服务器本身信息：run_id 域记录的服务器运行 ID，服务器角色。</li>
<li>主服务器属下所有从服务器信息：slaves 字段。</li>
</ul>
<h3 id="获取从服务器信息"><a href="#获取从服务器信息" class="headerlink" title="获取从服务器信息"></a>获取从服务器信息</h3><p>Sentinel 会创建连接到从服务器的命令连接和订阅连接。</p>
<p>会以每十秒一次的频率通过命令连接向从服务器发送 INFO 命令。</p>
<p>命令回复如下：</p>
<ul>
<li>从服务器的运行 ID run_id。</li>
<li>从服务器的角色 role。</li>
<li>主服务器的 IP 地址 master_host，以及主服务器的端口号 master_port。</li>
<li>主从服务器的连接状态 master_link_status。</li>
<li>从服务器的优先级 slave_priority。</li>
<li>从服务器的复制偏移量 slave_repl_offset。</li>
</ul>
<h3 id="向主服务器和从服务器发送信息"><a href="#向主服务器和从服务器发送信息" class="headerlink" title="向主服务器和从服务器发送信息"></a>向主服务器和从服务器发送信息</h3><p>默认情况下，Sentinel 会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送命令。</p>
<p>s_ 开头：记录的是 Sentinel 本身信息。</p>
<p>m_ 开头：记录的是主服务器的信息。</p>
<h3 id="接收来自主服务器和从服务器的频道信息"><a href="#接收来自主服务器和从服务器的频道信息" class="headerlink" title="接收来自主服务器和从服务器的频道信息"></a>接收来自主服务器和从服务器的频道信息</h3><p>对于每个与 Sentinel 连接的服务器，Sentinel 既通过命令连接向服务器的 _sentinel_:hello 频道发送信息，又通过订阅连接从服务器的 _sentinel_:hello 频道接收信息。</p>
<p>对于监视同一个服务器的多个 Sentinel 来说，一个 Sentinel 发送的信息会被其他 Sentinel 接收到，包括发送的 Sentinel 自身。</p>
<h4 id="更新-sentinels-字典"><a href="#更新-sentinels-字典" class="headerlink" title="更新 sentinels 字典"></a>更新 sentinels 字典</h4><p>Sentinel 还会记录除了自身之外的其他 Sentinels 信息。</p>
<h4 id="创建连向其他-Sentinel-的命令连接"><a href="#创建连向其他-Sentinel-的命令连接" class="headerlink" title="创建连向其他 Sentinel 的命令连接"></a>创建连向其他 Sentinel 的命令连接</h4><p>Sentinel 之间只会创建命令连接，不会创建订阅连接。</p>
<h3 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h3><p>默认情况下，Sentinel 会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他 Sentinel 在内）发送 PING 命令，并通过实例返回的 PING 命令回复来判断实例是否在线。</p>
<p>down-after-milliseconds 选项指定了 Sentinel 判断实例进入主观下线所需的时间长度，同样作用于监视 master 的其他 Sentinels。</p>
<h3 id="检测客观下线状态"><a href="#检测客观下线状态" class="headerlink" title="检测客观下线状态"></a>检测客观下线状态</h3><p>当 Sentinel 将一个主服务器判断为主观下线后，为了确认这个主服务器是否真的下线，它会向同样监视这一主服务器的其他 Sentinel 进行询问，看他们是否也认为主服务器已经进入下线状态。当接收的数量足够多时，Sentinel 就会将主服务器判定为客观下线，并执行故障转移。</p>
<h4 id="发送-SENTINEL-is-master-down-by-addr-命令"><a href="#发送-SENTINEL-is-master-down-by-addr-命令" class="headerlink" title="发送 SENTINEL is-master-down-by-addr 命令"></a>发送 SENTINEL is-master-down-by-addr 命令</h4><p>源 SENTINEL 服务器询问其他 SENTINEL 服务器主服务器是否已下线。</p>
<h4 id="接收-SENTINEL-is-master-down-by-addr-命令"><a href="#接收-SENTINEL-is-master-down-by-addr-命令" class="headerlink" title="接收 SENTINEL is-master-down-by-addr 命令"></a>接收 SENTINEL is-master-down-by-addr 命令</h4><p>目标 SENTINEL 接收到命令后，分析参数，进行命令回复。返回对主服务器的检查结果。</p>
<h4 id="接收-SENTINEL-is-master-down-by-addr-命令的回复"><a href="#接收-SENTINEL-is-master-down-by-addr-命令的回复" class="headerlink" title="接收 SENTINEL is-master-down-by-addr 命令的回复"></a>接收 SENTINEL is-master-down-by-addr 命令的回复</h4><p>根据其他 Sentinel 的命令回复， Sentinel 将统计其他 Sentinel 同意主服务器已下线的数量，当这一数量达到配置指定的客观下线所需数量时，会将祝福器进入客观下线状态。</p>
<h3 id="选举领头-Sentinel"><a href="#选举领头-Sentinel" class="headerlink" title="选举领头 Sentinel"></a>选举领头 Sentinel</h3><p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个 Sentinel 会进行协商，选举出一个领头 Sentinel，并由领头 Sentinel 对下线主观服务器执行故障转移操作。</p>
<p>选举的规则和方法：</p>
<ul>
<li>所有在线的 Sentinel 都有被选举为领头 Sentinel 的资格。</li>
<li>每次进行领头选举后，不论选举是否成功，所有 Sentinel 配置的纪元值都会自增一次。</li>
<li>在一个配置纪元里面，所有 Sentinel 都有一次将某个 Sentinel 设置为局部领头 Sentinel 的机会，并且局部领头一旦设置完成，在这个配置纪元里面就不能修改。</li>
<li>每个发现主服务器客观下线的 Sentinel 都会要求其他 Sentinel 将自己设置为局部领头 Sentinel。</li>
<li>Sentinel 设置局部领头 Sentinel 的规则是先到先得。</li>
<li>目标 Sentinel 接收到命令后，会向源 Sentinel 发送一条命令回复，回复中的 leader_runid 参数和 leader_epoch 参数分别记录了目标 Sentinel 的局部领头 Sentinel 的运行 ID 和配置纪元。</li>
<li>源 Sentinel 接收到目标 Sentinel 的命令回复后，检查配置纪元和自己的是否一致，如果相同，判断运行 ID 是否和自己一致，两者都一致表明目标 Sentinel 将源 Sentinel 设置为局部领头 Sentinel。</li>
<li>如果某个 Sentinel 被半数以上的 Sentinel 设置成了局部领头 Sentinel，那么这个 Sentinel 称为领头 Sentinel。</li>
<li>因为领头 Sentinel 需要半数以上的 Sentinel 的支持，并且每个 Sentinel 在每个配置纪元里面只能产生一次局部领头 Sentinel，所以在一次配置纪元里面只会出现一个领头 Sentinel。</li>
<li>如果在给定的时间内，没有一个 Sentinel 被选举为领头 Sentinel，那么会进行重新选举，直到选出领头 Sentinel 为止。</li>
</ul>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>选举出的领头 Sentinel 对已下线的主服务器进行故障转移</p>
<ol>
<li><p>在已下线的主服务器属下的所有从服务器里面，挑选一个从服务器，并将其转换为主服务器。</p>
<p> 挑选出一个状态良好、数据完整的从服务器，发送 SLAVEOF no one 命令。</p>
</li>
<li><p>让已下线的主服务器属下的所有从服务器改为复制新的主服务器。</p>
<p> 向其他从服务器发送 SLAVEOF 命令。</p>
</li>
<li><p>将已下线的主服务器设置为新主服务器的从服务器。</p>
<p> 已线下的服务器重新上线后，领头 Sentinel 发送 SLAVEOF 命令。</p>
</li>
</ol>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>刚开始的时候，每个节点是相互独立的，他们都处于只包含自己的集群中。</p>
<p>通过 <code>CLUSTER MEET</code> 命令完成。</p>
<h4 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h4><p>一个节点就是一个运行在集群模式下的 Redis 服务器。节点会继续使用单机模式下的服务器组件。</p>
<h4 id="集群数据结构"><a href="#集群数据结构" class="headerlink" title="集群数据结构"></a>集群数据结构</h4><p>每个节点都会使用一个 clusterNode 结构来记录自己的状态，并未集群中的所有其他节点（包括主节点和从节点）都创建一个相应的 clusterNode 结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 创建节点的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的名字</span></span><br><span class="line">    <span class="keyword">char</span> name[REDIS_CLUSTER_NAMELEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点标识</span></span><br><span class="line">    <span class="comment">// 使用各种不同的标识值记录节点的角色（比如主节点或者从节点）</span></span><br><span class="line">    <span class="comment">// 以及节点目前所处的状态（比如在线或者下线）</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点当前的配置纪元，用于实现故障转义</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的 IP 地址</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的端口</span></span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存连接节点所需的有关信息</span></span><br><span class="line">    clusterLink *link;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clusterNode 结构的 link 属性是一个 clusterLink 结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> sturct clusterLink &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接的创建时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCP 套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出缓冲区，保存着等待发送给其他节点的消息</span></span><br><span class="line">    sds sndbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入缓冲区，保存着从其他节点接收到的消息</span></span><br><span class="line">    sds rcvbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与这个连接相关联的节点，如果没有的话就为 NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span></span><br><span class="line">&#125; clusterLink;</span><br></pre></td></tr></table></figure>
<p>最后，每个节点都保存着一个 clusterState 结构，这个结构记录了在当前节点的视角下，集群目前所处的状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向当前节点的指针</span></span><br><span class="line">    clusterNode *myself;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群当前的状态：上线还是下线</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群中至少处理这一个槽的节点的数量</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群节点名单</span></span><br><span class="line">    <span class="comment">// 字典的键为节点的名字，字典的值为节点对应的 clusterNode 结构</span></span><br><span class="line">    dict *nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CLUSTER-MEET-命令的实现"><a href="#CLUSTER-MEET-命令的实现" class="headerlink" title="CLUSTER MEET 命令的实现"></a>CLUSTER MEET 命令的实现</h4><p>客户端向节点 A 发送 CLUSTER MEET 命令，收到命令的节点 A 将于节点 B 进行握手。</p>
<ol>
<li><p>节点 A 会为节点 B 创建一个 clusterNode 结构，并将该结构添加到自己的 clusterState.nodes 字典里面。</p>
</li>
<li><p>之后，节点 A 将根据 CLUSTER MEET 命令给定的 IP 地址和端口号，向节点 B 发送一条 MEET 消息。</p>
</li>
<li><p>如果一切顺利，节点 B 将接受到 节点 A 发送的 MEET 消息，节点 B 会为节点 A 创建一个 clusterNode 结构，并将该结构添加到自己的 clusterState.nodes 字典里面。</p>
</li>
<li><p>之后，节点 B 将向节点 A 返回一条 PONG 消息。</p>
</li>
<li><p>节点 A 接收到节点 B 返回的 PONG 消息后，就知道节点 B 成功接收到自己发送的 MEET 消息。</p>
</li>
<li><p>之后，节点 A 将向节点 B 返回一条 PING 消息。</p>
</li>
<li><p>节点 B 将接收到节点 A 返回的 PING 消息，通过这条消息节点 B 可以知道节点 A 已经成功接到自己返回的 PONG 消息，握手完成。</p>
</li>
</ol>
<p>握手完成后，节点 A 会将节点 B 的信息传播到集群中的其他节点，让其他节点与节点 B 进行握手，最终，节点 B 会被集群中的所有节点认识。</p>
<h3 id="指派槽"><a href="#指派槽" class="headerlink" title="指派槽"></a>指派槽</h3><p>Redis 集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384 个槽，数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或者最多16384个槽。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER ADDSLOTS &lt;slot&gt; [slot ...]</span><br></pre></td></tr></table></figure>
<h4 id="记录节点的槽指派信息"><a href="#记录节点的槽指派信息" class="headerlink" title="记录节点的槽指派信息"></a>记录节点的槽指派信息</h4><p>clusterNode 结构的 slots 属性和 numslot 属性记录了节点负责处理那些槽。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slots[<span class="number">16384</span>/<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numslots;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="传播节点的槽指派信息"><a href="#传播节点的槽指派信息" class="headerlink" title="传播节点的槽指派信息"></a>传播节点的槽指派信息</h4><p>一个节点除了将自己负责的槽记录在 clusterNode 结构的 slots 属性和 numslots 属性之外，还会将自己的 slots 数组通过消息发送给集群中的其他节点。</p>
<p>其他节点接收到数组后，会从自己的 clusterState.nodes 字典中查找对应的 clusterNode 结构，并对结构中的 slots 数组进行保存或者更新。</p>
<h4 id="记录所有槽的指派信息"><a href="#记录所有槽的指派信息" class="headerlink" title="记录所有槽的指派信息"></a>记录所有槽的指派信息</h4><p>clusterState 结构中的 slots 数组记录了集群中所有 16384 个槽的指派信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    clusterNode *slots[<span class="number">16384</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 slots[i] 指针指向 NULL，表示槽 i 尚未指派给任何节点。</li>
<li>如果 slots[i] 指针指向一个 clusterNode 结构，那么表示槽 i 已经指派给了 clusterNode 结构所代表的节点。</li>
</ul>
<h3 id="在集群中执行命令"><a href="#在集群中执行命令" class="headerlink" title="在集群中执行命令"></a>在集群中执行命令</h3><p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己：</p>
<ul>
<li>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。</li>
<li>如果没有指派给当前节点，那么节点会向客户端返回一个 MOVED 错误，指引客户端 redirect 至正确的节点，并在此发送之前的命令。</li>
</ul>
<h4 id="计算键属于哪个槽"><a href="#计算键属于哪个槽" class="headerlink" title="计算键属于哪个槽"></a>计算键属于哪个槽</h4><p>使用 <code>CLUSTER KEYSLOT &lt;key&gt;</code> 命令可以查看一个给定键属于哪个槽。</p>
<h4 id="判断槽是否由当前节点负责处理"><a href="#判断槽是否由当前节点负责处理" class="headerlink" title="判断槽是否由当前节点负责处理"></a>判断槽是否由当前节点负责处理</h4><p>如果 clusterState.slots[i] 等于 clusterState.myself，那么说明槽 i 由当前节点负责，节点可以执行命令。</p>
<p>否则，返回 MOVED 错误，并指引客户端转向至正在处理槽 i 的节点。</p>
<h4 id="MOVED-错误"><a href="#MOVED-错误" class="headerlink" title="MOVED 错误"></a>MOVED 错误</h4><p>错误格式：<code>MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code></p>
<h4 id="节点数据库的实现"><a href="#节点数据库的实现" class="headerlink" title="节点数据库的实现"></a>节点数据库的实现</h4><p>节点只能使用 0 号数据库。</p>
<h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><p>可以将任意数量已经指派给某个节点的槽改为指派给另一个节点，并且相关槽所属的键值对也会转移。</p>
<p>重写分片操作可以在线进行，并且指派的两个节点都可以继续处理命令请求。</p>
<h3 id="ASK-错误说明"><a href="#ASK-错误说明" class="headerlink" title="ASK 错误说明"></a>ASK 错误说明</h3><p>当客户端向源节点发送一个与数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽中。</p>
<ul>
<li>源节点优先在自己的数据库中查找指定的键，如果找到就执行命令。</li>
<li>如果没有找到，源节点将向客户端返回一个 ASK 错误，指引客户端转向正在导入槽的目标节点，并在此执行命令。</li>
</ul>
<h4 id="CLUSTER-SETSLOT-IMPORTING-命令的实现"><a href="#CLUSTER-SETSLOT-IMPORTING-命令的实现" class="headerlink" title="CLUSTER SETSLOT IMPORTING 命令的实现"></a>CLUSTER SETSLOT IMPORTING 命令的实现</h4><p>clusterState 结构的 importing_slots_from 数组记录了当前节点正在从其他节点导入的槽。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER SETSLOT &lt;i&gt; IMPORTING &lt;source_id&gt;</span><br></pre></td></tr></table></figure>
<h4 id="CLUSTER-SETSLOT-MIGRATING-命令的实现"><a href="#CLUSTER-SETSLOT-MIGRATING-命令的实现" class="headerlink" title="CLUSTER SETSLOT MIGRATING 命令的实现"></a>CLUSTER SETSLOT MIGRATING 命令的实现</h4><p>clusterState 结构的 migrating_slots_to 数组记录了当前节点正在迁移至其他节点的槽。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER SETSLOT &lt;i&gt; MIGRATING &lt;target_id&gt;</span><br></pre></td></tr></table></figure>
<h4 id="ASK-错误"><a href="#ASK-错误" class="headerlink" title="ASK 错误"></a>ASK 错误</h4><p>通过查找 migrating_slots_to[i]，确认 key 所属的槽 i 是否正在迁移。</p>
<p>如果正在迁移，则向客户端返回一个 ASK 错误，引导客户端到正在导入槽 i 的节点去查找 key。</p>
<h4 id="ASKING-命令"><a href="#ASKING-命令" class="headerlink" title="ASKING 命令"></a>ASKING 命令</h4><p>ASKING 命令唯一要做的就是打开发送命令客户端的 REDIS_ASKING 标识。REDIS_ASKING 是一次性标识。</p>
<p>节点判断是否执行客户端命令的过程</p>
<p><img src="http://picbed.jianghs.com/excute-client-command.png" alt="excute-client-command"></p>
<h4 id="ASK-错误和-MOVED-错误的区别"><a href="#ASK-错误和-MOVED-错误的区别" class="headerlink" title="ASK 错误和 MOVED 错误的区别"></a>ASK 错误和 MOVED 错误的区别</h4><ol>
<li>MOVED 错误代表槽的负责权已经从一个节点转移到另一个节点：在客户端收到关于槽 i 的 MOVED 错误之后，客户端每次遇到关于槽 i 的命令请求时，都可以直接将命令发送到 MOVED 错误指向的节点。</li>
<li>ASK 错误只是两个节点在迁移槽的过程中使用的一个临时措施：在客户端收到关于槽 i 的 ASK 错误之后，客户端只会在接下来的一次命令请求中将关于槽 i 的命令请求发送至 ASK 错误所指示的节点。</li>
</ol>
<h3 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h3><h4 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h4><p>可以让接收命令的节点称为 node_id 所指定节点的从节点，并开始对主节点进行复制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER REPLICATE &lt;node_id&gt;</span><br></pre></td></tr></table></figure>
<h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><p>集群中每个节点都会定期想集群中其他节点发送 PING 命令，如果接收到 PING 命令的其他节点没有在规定的时间内返回 PONG 消息，那么发送 PING 命令的节点就会将接收 PING 命令的节点标记为疑似下线（PFAIL）。</p>
<p>每个节点都会有一个链表，记录了所有其他节点对某个节点的下线报告。</p>
<p>如果在一个集群内，半数以上负责处理槽的主节点都将某个主节点 x 报告为疑似下线，那么这个节点 x 将会被标记为已下线。将 x 标记为已下线的节点将向集群广播 x 已下线的消息，其他节点收到消息都会将 x 标记为已下线。</p>
<h4 id="集群故障转移"><a href="#集群故障转移" class="headerlink" title="集群故障转移"></a>集群故障转移</h4><ol>
<li>复制下线主节点的所有从节点里面，会有一个从节点被选中。</li>
<li>被选中的从节点执行 SLAVEOF no one 命令，成为新的主节点。</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li>
<li>新的主节点向集群广播一条 PONG 消息，让集群中其他节点立即知道这个节点变更为主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li>
<li>新的主节点开始接收和负责自己处理槽的相关命令。</li>
</ol>
<h4 id="选举新的主节点"><a href="#选举新的主节点" class="headerlink" title="选举新的主节点"></a>选举新的主节点</h4><p>与选举领头 Sentinel 类似。</p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>MEET: 将接受者加入到接受者集群中。</p>
<p>PING: 检测选中的节点是否在线。</p>
<p>PONG: 接收到 MEET\PING 消息后回复 PONG 消息。集群内广播。</p>
<p>FAIL: 集群内广播某个节点已下线。</p>
<p>PUBLISH: 集群内广播 PUBLISH 消息，接收到消息的节点执行相同的 PUBLISH 命令。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"><i class="fa fa-tag"></i>Redis</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/28/JVM-性能监控与故障处理工具/" rel="next" title="JVM-性能监控与故障处理工具">
                <i class="fa fa-chevron-left"></i> JVM-性能监控与故障处理工具
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/09/JavaScript-DOM/" rel="prev" title="JavaScript DOM">
                JavaScript DOM <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/uploads/timg.jpeg" alt="J">
          <p class="site-author-name" itemprop="name">J</p>
          <p class="site-description motion-element" itemprop="description">A Coder</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">22</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/jianghs" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#复制"><span class="nav-number">1.</span> <span class="nav-text">复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#旧版复制功能的实现"><span class="nav-number">1.1.</span> <span class="nav-text">旧版复制功能的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同步"><span class="nav-number">1.1.1.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#命令传播"><span class="nav-number">1.1.2.</span> <span class="nav-text">命令传播</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#旧版复制功能的缺陷"><span class="nav-number">1.2.</span> <span class="nav-text">旧版复制功能的缺陷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新版复制功能的实现"><span class="nav-number">1.3.</span> <span class="nav-text">新版复制功能的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#部分重同步的实现"><span class="nav-number">1.4.</span> <span class="nav-text">部分重同步的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主服务器的复制偏移量和从服务器的复制偏移量"><span class="nav-number">1.4.1.</span> <span class="nav-text">主服务器的复制偏移量和从服务器的复制偏移量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主服务器的复制积压缓冲区"><span class="nav-number">1.4.2.</span> <span class="nav-text">主服务器的复制积压缓冲区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务器的运行-ID"><span class="nav-number">1.4.3.</span> <span class="nav-text">服务器的运行 ID</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PSYNC-命令的实现"><span class="nav-number">1.5.</span> <span class="nav-text">PSYNC 命令的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制的实现"><span class="nav-number">1.6.</span> <span class="nav-text">复制的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#心跳检测"><span class="nav-number">1.7.</span> <span class="nav-text">心跳检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#检测主从服务器网络连接状态"><span class="nav-number">1.7.1.</span> <span class="nav-text">检测主从服务器网络连接状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#辅助实现-min-slaves-选项"><span class="nav-number">1.7.2.</span> <span class="nav-text">辅助实现 min-slaves 选项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检测命令丢失"><span class="nav-number">1.7.3.</span> <span class="nav-text">检测命令丢失</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sentinel"><span class="nav-number">2.</span> <span class="nav-text">Sentinel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#启动并初始化-Sentinel"><span class="nav-number">2.1.</span> <span class="nav-text">启动并初始化 Sentinel</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化服务器"><span class="nav-number">2.1.1.</span> <span class="nav-text">初始化服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将普通-Redis-服务器使用的代码替换成-Sentinel-专用代码"><span class="nav-number">2.1.2.</span> <span class="nav-text">将普通 Redis 服务器使用的代码替换成 Sentinel 专用代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化-Sentinel-状态"><span class="nav-number">2.1.3.</span> <span class="nav-text">初始化 Sentinel 状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化-Sentinel-状态的-masters-属性"><span class="nav-number">2.1.4.</span> <span class="nav-text">初始化 Sentinel 状态的 masters 属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建连向主服务器的网络连接"><span class="nav-number">2.1.5.</span> <span class="nav-text">创建连向主服务器的网络连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取主服务器信息"><span class="nav-number">2.2.</span> <span class="nav-text">获取主服务器信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取从服务器信息"><span class="nav-number">2.3.</span> <span class="nav-text">获取从服务器信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向主服务器和从服务器发送信息"><span class="nav-number">2.4.</span> <span class="nav-text">向主服务器和从服务器发送信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接收来自主服务器和从服务器的频道信息"><span class="nav-number">2.5.</span> <span class="nav-text">接收来自主服务器和从服务器的频道信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#更新-sentinels-字典"><span class="nav-number">2.5.1.</span> <span class="nav-text">更新 sentinels 字典</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建连向其他-Sentinel-的命令连接"><span class="nav-number">2.5.2.</span> <span class="nav-text">创建连向其他 Sentinel 的命令连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检测主观下线状态"><span class="nav-number">2.6.</span> <span class="nav-text">检测主观下线状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检测客观下线状态"><span class="nav-number">2.7.</span> <span class="nav-text">检测客观下线状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发送-SENTINEL-is-master-down-by-addr-命令"><span class="nav-number">2.7.1.</span> <span class="nav-text">发送 SENTINEL is-master-down-by-addr 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收-SENTINEL-is-master-down-by-addr-命令"><span class="nav-number">2.7.2.</span> <span class="nav-text">接收 SENTINEL is-master-down-by-addr 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收-SENTINEL-is-master-down-by-addr-命令的回复"><span class="nav-number">2.7.3.</span> <span class="nav-text">接收 SENTINEL is-master-down-by-addr 命令的回复</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选举领头-Sentinel"><span class="nav-number">2.8.</span> <span class="nav-text">选举领头 Sentinel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#故障转移"><span class="nav-number">2.9.</span> <span class="nav-text">故障转移</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群"><span class="nav-number">3.</span> <span class="nav-text">集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#节点"><span class="nav-number">3.1.</span> <span class="nav-text">节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#启动节点"><span class="nav-number">3.1.1.</span> <span class="nav-text">启动节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集群数据结构"><span class="nav-number">3.1.2.</span> <span class="nav-text">集群数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CLUSTER-MEET-命令的实现"><span class="nav-number">3.1.3.</span> <span class="nav-text">CLUSTER MEET 命令的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指派槽"><span class="nav-number">3.2.</span> <span class="nav-text">指派槽</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#记录节点的槽指派信息"><span class="nav-number">3.2.1.</span> <span class="nav-text">记录节点的槽指派信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传播节点的槽指派信息"><span class="nav-number">3.2.2.</span> <span class="nav-text">传播节点的槽指派信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#记录所有槽的指派信息"><span class="nav-number">3.2.3.</span> <span class="nav-text">记录所有槽的指派信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在集群中执行命令"><span class="nav-number">3.3.</span> <span class="nav-text">在集群中执行命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#计算键属于哪个槽"><span class="nav-number">3.3.1.</span> <span class="nav-text">计算键属于哪个槽</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断槽是否由当前节点负责处理"><span class="nav-number">3.3.2.</span> <span class="nav-text">判断槽是否由当前节点负责处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MOVED-错误"><span class="nav-number">3.3.3.</span> <span class="nav-text">MOVED 错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#节点数据库的实现"><span class="nav-number">3.3.4.</span> <span class="nav-text">节点数据库的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重新分片"><span class="nav-number">3.4.</span> <span class="nav-text">重新分片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASK-错误说明"><span class="nav-number">3.5.</span> <span class="nav-text">ASK 错误说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CLUSTER-SETSLOT-IMPORTING-命令的实现"><span class="nav-number">3.5.1.</span> <span class="nav-text">CLUSTER SETSLOT IMPORTING 命令的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CLUSTER-SETSLOT-MIGRATING-命令的实现"><span class="nav-number">3.5.2.</span> <span class="nav-text">CLUSTER SETSLOT MIGRATING 命令的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ASK-错误"><span class="nav-number">3.5.3.</span> <span class="nav-text">ASK 错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ASKING-命令"><span class="nav-number">3.5.4.</span> <span class="nav-text">ASKING 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ASK-错误和-MOVED-错误的区别"><span class="nav-number">3.5.5.</span> <span class="nav-text">ASK 错误和 MOVED 错误的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制与故障转移"><span class="nav-number">3.6.</span> <span class="nav-text">复制与故障转移</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#设置从节点"><span class="nav-number">3.6.1.</span> <span class="nav-text">设置从节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#故障检测"><span class="nav-number">3.6.2.</span> <span class="nav-text">故障检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集群故障转移"><span class="nav-number">3.6.3.</span> <span class="nav-text">集群故障转移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选举新的主节点"><span class="nav-number">3.6.4.</span> <span class="nav-text">选举新的主节点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息"><span class="nav-number">3.7.</span> <span class="nav-text">消息</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">J</span>
</div>

<div>
      <!--统计start-->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
</div>
<div>
      <span id="busuanzi_container_site_uv">
  总访客数<span id="busuanzi_value_site_uv"></span>人次
  </span>
      <!--统计end-->
</div>


<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共31k字</span>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
