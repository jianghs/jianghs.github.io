---
title: JVM-垃圾收集器与内存收集策略
date: 2019-07-22 13:36:22
tags: JVM
categories: coding
---
## 概要

程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。垃圾收集器关注的是堆中的内存。

## 对象已死吗

### 引用计数算法

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

缺点:很难解决对象之间互相循环引用的问题。

### 可达性分析算法

通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（ Reference Chain ），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。

Java 中可以作为 GC Roots 的对象包括以下:

1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中 JNI (本地方法)引用的对象

### 引用

无论使用何种算法，垃圾回收都和“引用”有关。

jdk 1.2之前：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。

jdk 1.2之后：

1. 强引用(Strong)
2. 软引用(Soft)
3. 弱引用(Weak)
4. 虚引用(Phantom)

### 对象逃脱被被回收的过程

1. 可达性分析发现与 GC Roots 没有引用链，进行第一次标记并进行筛选，条件为此对象是否有必要执行 finalize() 方法。
2. 如果没有重写 finalize() 方法或者虚拟机已经执行过该方法，则认为没有必要执行。
3. 如果判定为有必要执行，这个对象会被放到一个 F-Quene 对列中，由虚拟机自建立一个低优先级的 Finalizer 线程执行。虚拟机会触发这个线程执行，但并不保证等待它执行完成。
4. GC 会对队列中的对象进行一次小规模标记。如果对象可以在 finalize() 方法中与引用链中的任意对象建立联系，就会移除出“被回收集合”。

备注: finalize()方法不建议使用。

### 回收方法区

1. 废弃常量

    常量没有被其他地方引用，则可以被回收。

2. 无用的类
    * 该类的所有实例均被回收。
    * 加载该类的 ClassLoader 已被回收
    * 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 垃圾收集算法

### 标记-清除算法

分为标记和清除两个阶段，首先标记待回收的对象，标记完成后统一回收。

缺点:

1. 效率问题
2. 空间问题，产生大量不连续的内存空间碎片。

### 复制算法

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

优点：效率高

缺点：将内存缩小为原来的一半

一般采用此算法来回收新生代。现代虚拟机不是1:1划分，分为一块较大的 Eden 区和两块较小的 Survivor 区。

如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。

### 标记-整理算法

分为标记和整理两个阶段，标记和上述一致，整理是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

### 分代收集算法

根据对象存活周期的不同，将内存分为几块。Java 堆一般分为新生代和老年代。新生代采用复制算法，老年代采用标记清除或者标记整理算法。

## HotSpot 算法

### 枚举根节点

1. 根节点主要在全局性引用和执行上下文中，方法区空间很大时，逐个查询效率很低。
2. GC 停顿，使用 OopMap

### 安全点-程序执行时通过安全点判断

1. 以是否具有让程序长时间执行的特征为标准，“长时间”最明显的特征就是指令序列复用，如方法调用、循环跳转、异常跳转。
2. 如何在GC发生时让线程跑到最近的安全点上在停顿下来？
    * 抢先式中断，几乎没有虚拟机选择。
    * 主动式中断

      当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。
3. 安全区域-程序不执行时通过安全区域判断
安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。

## HotSpot 垃圾收集器

![hotspot](https://raw.githubusercontent.com/jianghs/myBlogPicBed/master/jvm/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png)

### Serial 收集器-新生代

* 单线程
* 进行垃圾收集时必须暂停其他线程。
* 简单高效，适合运行在 Client 模式下的虚拟机。

### ParNew 收集器-新生代

* Serial 收集器的多线程版本
* server 模式下虚拟机新生代垃圾收集的首选
* 与 CMS 收集器搭配使用

### Parallel Scavenge-新生代

* 使用复制算法，并且是并行的多线程收集器。
* 适合后台运算不需要多交互的任务。
* 吞吐量优先
* 自适应调节

### Serial Old-老年代

* 单线程，使用标记-整理算法的收集器
* Client 模式下使用
* 如果在 Server 模式下

  在 JDK 1.5以及之前的版本中与 Parallel Scavenge 收集器搭配使用。
* 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

### Parallel Old-老年代

* Parallel Scavenge 老年代版本。
* 多线程
* 标记-整理算法
* 吞吐量优先

### CMS 收集器-老年代

* 基于标记-清除算法
* 步骤：

  初始标记、并发标记、重新标记、并发清除
* 优点：并发收集、低停顿
* 缺点：对 CPU 资源非常敏感、无法处理浮动垃圾、产生大量空间碎片

### G1 收集器

* 特点：
  1. 并行与并发
  2. 分代收集
  3. 空间整合
  4. 可预测的停顿

## 内存分配与回收策略

1. 对象优先在 Eden 分配
2. 大对象直接进入老年代

    大对象：需要大量连续内存空间的java对象，典型如很大的字符串或者数组。

    虚拟机提供了一个 `-XX:PretenureSizeThreshold` 参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制(新生代采用复制算法收集内存)。

3. 长期存活的对象将进入老年代

    虚拟机给每个对象定义了一个对象年龄（Age）计数器。

    如果对象在Eden出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为1。

    对象在 Survivor 区中每“熬过”一次 Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。

4. 动态对象年龄判定

    虚拟机并不是永远地要求对象的年龄必须达到了 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。

5. 空间分配担保

    Minor GC 之前

    1. 如果老年代最大可用连续内存空间＞新生代所有对象总和，Minor GC 确保安全。

    2. 否则，检查 HandlePromotionFailure 是否允许担保失败。
    3. 如果不允许，进行一次 Full GC。
    4. 如果允许，检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果是则尝试进行一次 Minor GC，否则进行一次 Full GC。
