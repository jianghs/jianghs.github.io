---
title: Redis 单机数据库的实现
date: 2019-07-23 09:52:23
tags: Redis
categories: coding
---
## 数据库

### 服务器中的数据库

结构如下：

```c
struct redisServer {
  // 保存着服务器上所有数据库的数组
  redisDb *db;
  // 服务器的数据库数量
  int dbnum;
}
```

初始化的时候会根据 dbnum 决定数据库的数量，默认为16。

### 切换数据库

默认情况下，Redis 客户端的目标数据库是0号数据库。

```c
struct redisClient {
  // 记录客户端当前正在使用的数据库
  redisDb *db;
}
```

通过修改 redisClient.db 指针，让它指向不同的数据库，从而实现切换数据库的功能——这个是 select 命令的实现原理。

### 数据库键空间

Redis 是一个键值对数据库服务器，服务器中的每个数据库结构用 dict 字典保存所有的键值对。这个字典被称为键空间。

键空间的键，也就是数据库的键，每个键都是一个字符串对象。

键空间的值，也是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象、有序集合对象中的任一 Redis 对象。

#### 添加新键

实际是将一个新键值添加到键空间字典里面。

```redis
SET key "value"
```

#### 删除键

实际是在键空间里删除对应的键值对对象。

```redis
DEL key
```

#### 更新键

实际是对键空间的键对应的值对象进行更新。

```redis
SET key "newvalue"
```

#### 对键取值

在键空间取出键对应的值对象。

```redis
GET key
```

#### 其他键空间操作

|操作|说明|
| --- | --- |
| FLUSHDB | 清除数据库 |
| RANDOMKEY | 随机返回数据库的一个 key |
| DBSIZE | 获取数据库键数量 |

#### 读写键空间的维护操作

* 读取一个键之后，服务器会根据键是否存在更新服务器的键空间命中次数或不命中次数。

* 读取一个键后，服务器更新这个键的 LRU 时间。

* 如果服务器读取一个键时，发现键已过期，服务器会先删除过期键，然后进行后续操作。

* 如果客户端会用 WATCH 命令监控了某个键，那么服务器在对被监控的键进行修改后，会将这个键标记为脏（dirty）,从而让事务程序注意这个键已被修改。

* 服务器每修改一次键，则会对脏键计数器加一，这个计数器会触发服务器的持久化以及复制操作。

* 如果服务器配置了通知功能，在对键进行修改之后，服务器会根据配置发送相应的数据库通知。

### 设置键的生存时间或过期时间

* 设置生存时间

  ```Redis
  EXPIRE keyname 5
  ```

* 设置过期时间点

  ```Redis
  EXPIREAT keyname 111231231
  ```

#### 设置过期时间

* EXPIRE \<key\> \<ttl\> 将键 key 的生存时间设置为 ttl 秒。
* PEXPIRE \<key\> \<ttl\> 将键 key 的生存时间设置为 ttl 毫秒。
* EXPIREAT \<key\> \<timestamp\> 将键 key 的过期时间设置为 timestamp 指定的秒数时间戳。
* PEXPIREAT \<key\> \<timestamp\> 将键 key 的生存时间设置为  timestamp 指定的毫秒时间戳。

都是根据 PEXPIREAT 命令转换来执行。

#### 保存过期时间

过期字典的键是一个指针，这个指针指向键空间的某个键对象。

过期字典的值是一个 long 类型的整数，这个整数保存了键所指向的数据库键的过期时间-一个毫秒精度的时间戳。

#### 移除过期时间

PERSIST 命令可以移除一个键的过期时间。

#### 计算并返回剩余生存时间

TTL 命令以秒为单位返回键的剩余生存时间。

PTTL 命令以毫秒为单位返回键的剩余生存时间。

#### 过期键的判定

1. 检查给定键是否存在于过期字典，如果存在，取得键的过期时间。
2. 如果当前时间戳大于过期时间，那么键已过期。

### 过期键删除策略

* 定时删除
  
  设置键的过期时间的同时，创建了一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。
* 惰性删除：

  放任键过期不管，每次从键空间获取键时，检查键是否过期，如果过期的话，就删除键。
* 定期删除：

  每隔一段时间，程序对数据库进行一次检查，删除里面的过期键。

第一和第三种是主动删除，第二种是被动删除。

|类型|优点|缺点|
|---|---|---|
|定时删除|保证键尽快的被删除，释放内存|过期键较多时，占用较多 CPU 时间|
|惰性删除|不会占用过多 CPU 时间|对内存最不友好|
|定期删除|折中策略|难以确定删除操作的时长和频率|

### Redis 的过期键删除策略

Redis 服务器实际采用惰性删除和定期删除策略结合的方式。

### AOF、RDB 和复制功能对过期键的处理

#### 生成 RDB 文件

已过期键不会写入 RDB 文件。

#### 载入 RDB 文件

如果服务器以主服务器的方式运行，程序会对文件中的键进行过期检查，过期键会被忽略。

如果服务器以从服务器的方式运行，文件中的所有键都会载入。但是主从服务器同步数据时，从服务器数据会清空。

#### AOF 文件写入

当服务器以 AOF 持久化模式运行时，如果数据库中某个键已经过期，但它还没有被删除，那么 AOF 文件不会因为这个过期键产生任何影响。

当这个键被删除后，程序会向 AOF 文件追加一条 DEL 命令，显式的删除这个键。

#### AOF 重写

已过期键不会重写进 AOF 文件。

#### 复制

服务器运行在复制模式下时，从服务器的过期键删除由主服务器控制：

1. 主服务器删除一个过期键后，显式的向所有从服务器发送一个 DEL 命令，告知从服务器删除这个过期键。
2. 从服务器执行客户端发来的命令时，即使碰到过期键也不会删除。
3. 从服务器只有接受到主服务器发来的 DEL 命令时，才会删除过期键。

### 数据库通知

可以让客户端通过订阅给定的频道或者模式，获取数据库中键的变化，以及数据库中命令的执行情况。

## RDB 持久化

### RDB 文件的创建和载入

`SAVE` 命令会阻塞 Redis 服务器进程，直到 RDB 文件创建完成，在服务器进程阻塞期间，服务器不能处理任何请求。

`BGSAVE`命令会派生一个子进程，由子进程生成 RDB 文件，父进程继续处理请求。

RDB 文件载入的工作是在服务器启动时自动执行的。

因为 AOF 文件的更新频率通常比 RDB 文件高，所以如果服务器开启了 AOF 持久化，会优先载入 AOF 文件。

#### SAVE 命令执行时服务器的状态

服务器处于阻塞状态。

#### BGSAVE 命令执行时服务器的状态

1. 客户端发送的 SAVE 命令会被拒绝。
2. 客户端发送的 BGSAVE 命令也会被拒绝。
3. BGREWRITEAOF 和 BGSAVE 不能同时进行。

#### RDB 载入时服务器的状态

服务器处于阻塞状态。

### 自动间隔性保存

Redis 允许用户通过设置保存条件，让服务器每隔一段时间自动执行一次 BGSAVE 命令。

可以设置多个保存条件，只要有一个满足条件，即可执行 BGSAVE 命令。

#### 设置保存条件

服务器在900秒内，至少对数据库进行了1次修改。

```redis
save 900 1
```

### RDB 文件结构

![RDB](https://raw.githubusercontent.com/jianghs/myBlogPicBed/master/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%88%AA%E5%9B%BE/RDB_file_structure.png)

* REDIS：程序载入时快速检查是否时 RDB 文件。
* db_version：4个字节，记录 RDB 文件版本号。
* databases：包含零个或者任意多个数据库。
* EOF：标志着 RDB 文件正文内容的结束。
* check_sum：校验和，由上述4个信息计算而得。

#### databases

一个 RDB 文件的 databases 部分可以保存任意多个非空数据库。

![RDB-databases](https://raw.githubusercontent.com/jianghs/myBlogPicBed/master/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%88%AA%E5%9B%BE/RDB_databases.png)

* SELECTDB：表明接下来读入的将是一个数据库号码。
* db_number：记录的是数据库号码。
* key_value_pairs：保存了数据库所有的键值对数据。

#### key_value_pairs

RDB 文件中的每个 key_value_pairs 部分都保存了一个或以上数量的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存。

* TYPE 记录了 value 的类型。
* key 总是一个字符串对象。
* 根据 TYPE 类型不同，以及保存内容长度不同，保存 value 的结构和长度也会有所不同。

![key_value](https://raw.githubusercontent.com/jianghs/myBlogPicBed/master/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%88%AA%E5%9B%BE/key_value_without_expire.png)

* EXPIRETIME_MS 表示接下来是过期时间
* ms 表示时间戳。

![key_value_expire](https://raw.githubusercontent.com/jianghs/myBlogPicBed/master/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%88%AA%E5%9B%BE/key_value_with_expire.png)

#### value

|TYPE|value|
|---|---|
|REDIS_RDB_TYPE_STRING|字符串对象|
|REDIS_RDB_TYPE_LIST|列表对象|
|REDIS_RDB_TYPE_SET|集合对象|
|REDIS_RDB_TYPE_HASH|哈希表对象|
|REDIS_RDB_TYPE_ZSET|有序集合对象|
|REDIS_RDB_TYPE_INTSET|INTSET 编码的集合|
|REDIS_RDB_TYPE_LIST_ZIPLIST|压缩列表对象|
|REDIS_RDB_TYPE_HASH_ZIPLIST|压缩列表对象|
|REDIS_RDB_TYPE_ZSET_ZIPLIST|压缩列表对象|

## AOF 持久化

通过保存 Redis 服务器所执行的写命令来记录数据库状态。

### AOF 持久化的实现

1. 命令追加-append
2. 文件写入
3. 文件同步-sync

#### 命令追加

AOF 持久化功能打开时， 服务器执行完一个写命令时，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾。

#### AOF 文件的写入与同步

`flushAppendOnlyFile()` 将 aof_buf 缓冲区的内容写入和保存到 AOF 文件。

`flushAppendOnlyFile()` 行为由服务器配置的 appendfsync 选项的值决定。

|appendfsync|flushAppendOnlyFile函数的行为|效率|安全性|
|---|---|---|---|
|always|将 aof_buf 缓冲区的所有内容写入并同步到 AOF 文件|低|高，只丢失一个事件循环数据|
|everysec（默认）|将 aof_buf 缓冲区的所有内容写入到 AOF 文件，如果上次同步 AOF 文件的时间距离现在超过一秒，那么在此对 AOF 文件同步，并且这个同步由一个线程专门执行|高|只丢失一秒钟命令数据|
|no|将 aof_buf 缓冲区的所有内容写入到 AOF 文件，但并不对 AOF 文件进行同步，何时同步由操作系统决定|最高|丢失上次同步之后的所有命令数据|

### AOF 文件的载入和数据还原

![AOF_LOAD](https://raw.githubusercontent.com/jianghs/myBlogPicBed/master/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%88%AA%E5%9B%BE/AOF_LOAD.png)

### AOF 的重写

为了解决 AOF 文件体积膨胀问题。

通过该功能，Redis 服务器可以创建一个新的 AOF 文件代替现有的 AOF 文件，新旧文件包含的命令数据一样，但是新的文件不会包含任何浪费空间的冗余命令。

#### 实现

首先从数据库读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。

#### 后台重写

AOF 重写在子进程执行。

1. 子进程重写期间，不影响父进程执行命令。
2. 子进程带有父进程的数据副本，是有子进程而不是线程，可以避免在锁的情况下，保证数据的安全性。

为了解决父子进程数据不一致的情况，Redis 设置了一个 AOF 重写缓冲区。这个缓冲区在服务器创建子进程后开始使用，当 Redis 服务器执行完一个写命令之后，会同时将这个命令发给 AOF 缓冲区和 AOF 重写缓冲区。

子进程执行 AOF 重写期间，服务器进程执行一下三个工作：

1. 执行客户端发来的命令。
2. 将执行后的写命令追加到 AOF 缓冲区。
3. 将执行后的写命令追加到 AOF 重写缓冲区。

当子进程完成 AOF 重写工作后，会向父进程发送一个信号，父进程收到该信号之后，会执行：

1. 将 AOF 重写缓冲区的所有内容写入到新的 AOF 文件中，这是 AOF 文件所保存的数据库状态和服务器当前状态一致。
2. 对新的 AOF 文件进行改名，原子地覆盖现有的 AOF 文件，完成新旧两个 AOF 文件替换。

## 事件

Redis 服务器是一个时间驱动程序

* 文件事件
* 时间事件

### 文件事件

文件事件处理器使用 I/O 多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。

当被监听的套接字准备好执行连接应答（accept）\读取（read）\写入（write）\关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。

#### 文件事件处理器的构成

1. 套接字
2. I/O 多路复用程序
3. 文件事件分派器
4. 事件处理器

![file_event_processor](https://raw.githubusercontent.com/jianghs/myBlogPicBed/master/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%88%AA%E5%9B%BE/file_event_processor.png)

#### I/O 多路复用程序的实现

通过包装常见的 select\epoll\evport 和 kqueue 这些 I/O 多路复用函数库来实现。

#### 事件的类型

|套接字|客户端对套接字的操作|事件类型|
|---|---|---|
|可读|wirte|AE_READABLE|
|可读|close|AE_READABLE|
|可应答|acceptable|AE_READABLE|
|可写|read|AE_WRITABLE|

#### API

略

#### 文件事件的处理器

1. 连接应答处理器
2. 命令请求处理器
3. 命令回复处理器

客户端和服务器通信过程

![client_server_connect](https://raw.githubusercontent.com/jianghs/myBlogPicBed/master/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%88%AA%E5%9B%BE/client_server_connect.png)

### 时间事件

1. 定时事件：指定事件后执行一次。
2. 周期性事件：每隔指定时间执行一次。

一个时间事件的组成：

1. id: 时间事件全局唯一 ID，从小到大一次排列，新事件的 ID 比旧事件 ID 号大。
2. when: 毫秒级时间戳，记录事件到达时间。
3. timeProc: 时间处理器，一个函数。

函数返回值决定是定时事件还是周期性事件。

1. 如果返回的是 AE_NOMORE，那么事件为定时事件。该事件在到达一次之后就会被删除。
2. 如果返回的非 AE_NOMORE，那么事件为周期性事件。该事件到达之后，服务器会根据时间处理器返回值设置 when，让这个时间再次到达。

#### 时间事件实现

将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，就遍历整个链表，查找所有已达的时间事件，并调用相应的事件处理器。

### 事件的调度与执行

![server_process_under_event](https://raw.githubusercontent.com/jianghs/myBlogPicBed/master/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%88%AA%E5%9B%BE/server_process_under_event.png)

因为时间事件在文件事件之后执行，所以通常时间事件会有延迟的情况。

## 客户端

Redis 一个服务器可以和多个客户端创建网络连接。

Redis 服务器状态结构的 clients 属性是一个链表，保存了所有与服务器连接的客户端状态。

### 客户端属性

* 通用属性
* 和特定功能相关的属性

#### 套接字描述符

* fd 等于-1：伪客户端，源于 AOF 文件或者 Lua 脚本，而非来自网络。
* fd 大于-1: 普通客户端。

#### 名字

默认情况 name 属性为空，可手动设置。

#### 标志

flags 记录了客户端的角色，以及客户端目前所处的状态。

可以是单个标志

```c
flags = <flag>
```

可以是多个标志的二进制或

```c
flags = <flag1> | <flag2> | ...
```

#### 输入缓冲区

querybuf 会根据输入内容动态的缩小或扩大，但它的最大不能超过1 GB，否则服务器会关闭这个客户端。

#### 命令与命令参数

命令参数和命令参数个数保存在 argv 属性和 argc 属性。

argv[0] 是要执行的命令，之后的其他项是传给命令的参数。argc 属性负责记录 argv 数组的长度。

#### 命令的实现函数

服务器根据 argv[0] 的值，在命令表中查找命令所对应的命令实现函数。将 cmd 指向对应的 redisCommand 结构。

命令表的查找不区分大小写。

#### 输出缓冲区

* 固定大小缓冲区：保存长度比较小的回复。
* 可变大小缓冲区：保存长度比较大的回复，长字符串，多项组成的列表，包含很多元素的集合。

#### 身份验证

authenticated 记录客户端是否通过身份验证。

* 0： 未通过
* 1： 通过

仅在服务器开启了身份验证时使用。

#### 时间

* ctime: 创建客户端的时间。
* lastinteraction: 客户端与服务器最后一次互动的时间。
* obuf_soft_limit_reached_time: 输出缓冲区第一次到达软性限制的时间。

### 客户端的创建与关闭

#### 创建普通客户端

客户端使用 connect 函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构 clients 链表的末尾。

#### 关闭普通客户端

关闭原因很多，不做赘述。

#### Lua 脚本的伪客户端

Redis 服务器初始化时，创建负责执行 Lua 脚本中包含 Redis 命令的伪客户端，并将这个伪客户端关联在服务器状态结构的 lua_client 属性中。

服务器关闭时，这个客户端才会关闭。

#### AOF 文件的伪客户端

服务器载入文件时，创建伪客户端，载入完毕后，关闭这个客户端。

## 服务器

### 命令请求的执行过程

#### 发送命令请求

客户端将这个命令转换成协议格式，通过连接到服务器的套接字，将协议格式的命令请求发送给服务器。

#### 读取命令请求

1. 读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。
2. 对输入缓冲区中的命令请求进行分析，提取命令请求中包含的命令参数及命令参数个数，分别保存在客户端状态的 argv 属性和 argc 属性。
3. 调用命令执行器，执行客户端指定的命令。

#### 命令执行器（1）- 查找命令实现

根据 argv[0] 参数，在命令表中查找参数指定的命令，并将命令保存到客户端状态的 cmd 属性中。

#### 命令执行器（2）- 执行预备操作

预备操作确保命令正确、顺利的执行。

#### 命令执行器（3）- 调用命令的实现函数

命令的实现函数只需要一个指向客户端状态的指针作为参数即可。

被调用的命令实现函数会执行指定的操作，并产生相应的命令回复，这些回复会保存在客户端状态的输出缓冲区里面，之后实现函数还会为客户端的套接字关联命令回复处理器。

#### 命令执行器（4）- 执行后续工作

1. 添加一条新的慢查询日志
2. 更新 redisCommand 结构的 millseconds 属性，并将 calls 计数器的值加一。
3. AOF 持久化开启，会将刚执行的命令添加到 AOF 缓冲区。
4. 如果其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。

#### 将命令回复发送给客户端

命令回复发送完毕后，回复处理器会清空客户端状态的输出缓冲区。

#### 客户端接收并打印命令回复

将回复格式化成人类可读的格式并显示。

### serverCron 函数

默认每隔100毫秒执行一次。

#### 更新服务器时间缓存

为了减少调用系统时间的次数，采用服务器时间缓存。

#### 更新 LRU 时钟

每10秒一次的频率更新一次 LRU 时钟。

#### 更新服务器每秒执行命令的次数

traceOperationsPerSeconds 函数会以每100毫秒一次的频率执行，估算并记录服务器在最近一秒钟处理的命令请求的数量。

#### 更新服务器内存峰值记录

当前使用内存如果比 stat_peak_memory 大，则更新 stat_peak_memory。

#### 处理 SIGTERM 信号

服务器启动是会将 SIGTERM 关联处理器 sigtermHandler 函数，这个信号处理器负责在服务器接收到 SIGTERM 信号时，打开服务器状态的 shutdown_asap 标识。

每次 serverCron 函数运行时，程序都会对 shutdown_asap 标识检查，决定是否关闭服务器。

#### 管理客户端资源

serverCron 函数每次执行都会调用 clientCron 函数，clientCron 会进行两个检查：

1. 如果客户端和服务器之间的连接已超时，那么程序释放这个客户端。
2. 如果客户端上一次执行命令请求后，输入缓冲区的大小超过了一定长度，释放当前客户端输入缓冲区，并创建一个默认大小的输入缓冲区。

#### 管理数据库资源

serverCron 函数每次执行都会调用 databasesCron 函数，这个函数会对服务器一部分数据库检查，删除其中的过期键，并在有需要时，对字典进行收缩。

#### 执行被延迟的 BGREWRITEAOF

serverCron 函数每次执行时，函数都会检查 BGSAVE 或者 BGREWRITEAOF 命令是否正在执行，如果都没有执行，并且 aof_rewrite_scheduled 属性为1，那么服务器执行被延迟的 BGREWRITEAOF。

#### 检查持久化操作的运行状态

serverCron 函数每次执行时，函数会检查 rdb_child_pid 和 aof_child_pid 两个属性的值，检查子进程是否有信号发来。

#### 将 AOF 缓冲区中的内容写入 AOF 文件

serverCron 函数每次执行时，函数将 AOF 缓冲区中的内容写入 AOF 文件。

#### 关闭异步客户端

关闭输出缓冲区超过限制的客户端。

#### 增加 cronloops 计数器值

记录 serverCron 执行的次数。

### 初始化服务器

#### 初始化服务器状态结构

创建一个 struct redisServer 类型的实例变量 server 座位服务器的状态，并为结构中的各个属性设置默认值。

#### 载入配置选项

通过给定参数或者指定配置文件来修改服务器的默认配置。

#### 初始化服务器数据结构

初始化服务器中除了命令表之外的其他数据结构。

#### 还原数据库状态

* 如果启用 AOF 持久化功能，服务器使用 AOF 文件来还原数据库状态。
* 否则用 RDB 文件还原数据库状态。

#### 执行事件循环

开始执行服务器的事件循环。
