---
title: JVM-内存区域
date: 2019-07-22 10:54:38
tags: JVM
categories: coding
---
## Java 技术体系

1. Java 程序设计语言
2. 各个硬件平台的 Java 虚拟机
3. Class 文件格式
4. Java API 类库
5. 来自商业机构和开源社区的第三方 Java 类库

其中1、2、4项合称为JDK

![JDK 结构](http://picbed.jianghs.com/JDK.JPG)

## 自动内存管理机制

### 运行时内存区域

* 程序计数器
* 虚拟机栈
* 本地方法栈
* 堆
* 方法区

#### 程序计数器

1. 当前线程所执行的字节码的行号指示器。
2. 每个线程都有独立的计数器，各个线程的之间的计数器互不影响，独立存储。“线程私有”内存。
3. 如果线程执行的是一个 Java 方法，该计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是 Native 方法，这个计数器值则为空。
4. 此区域是唯一一个在 Java 虚拟机规范中没有规定任务 OutOfMemoryError 情况的区域。

#### Java 虚拟机栈

1. 线程私有
2. Java 方法执行的内存模型
3. 方法执行的同时创建一个栈帧，存储:局部变量表、操作数栈、动态链接、方法出口等。
4. 每个方法从创建直至调用完成，对应栈帧在虚拟机栈的入栈到出栈。
5. 局部变量表:基本数据类型、对象引用和 returnAddress 类型，64位 long 和 double 类型占2个空间，其他类型占用1个空间。
6. 2个异常: StackOverFlow 和 OutOfMemory

#### 本地方法栈

1. 本地方法执行的内存模型
2. 部分虚拟机将虚拟机栈和本地方法栈合二为一。
3. 也会抛出两个异常。

#### 堆

1. 内存管理中最大的一块
2. 所有线程共享，虚拟机启动时创建。
3. 存放实例对象、数组。
4. 是垃圾回收的主要区域，有时也被称为"GC"堆。
5. 堆物理上可以不是连续的内存空间，只需要逻辑上连续即可。

#### 方法区

1. 所有线程共享
2. 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译产生的代码等。
3. 对应 HotSpot 虚拟机永久代。
4. 可以选择固定或者可扩展内存。
5. 可以选择不进行垃圾收集。

#### 运行时常量池

1. 方法区的一部分
2. 存放编译期产生的各种字面量和符号引用，类加载时进入方法区的运行时常量池存放。
3. 动态性，运行期间也可能将新的常量放入池中。

#### 直接内存

1. 不是 Java 内存管理的一部分
2. 注意所有内存之和超过物理总内存。

## HotSpot 虚拟机探秘

讨论 HotSpot 虚拟机在 Java 堆中对象分配、布局、访问全过程。

### 对象的创建

1. 检查 new 指令参数能否在常量池定位到一个符号引用，并且检查这个符号引用对应的类是否已经被加载、解析和初始化过。
2. 如果没有，则执行类加载过程。此时已经确定了需分配的内存大小。
3. 为新生对象分配内存
   * 分配方式:
     * 内存绝对规整，指针碰撞
     * 内存不是连续的，空闲列表

     选取哪种分配方式由内存是否规整决定，而内存是否规整由垃圾回收器是否带走压缩整理功能决定。
   * 解决线程安全
     * 对分配内存动作进行同步处理:CAS 加失败重试
     * 内存分配动作按照线程划分在不同区域进行，即每个线程在堆中划分一个本地线程分配缓冲 TLAB (本地线程分配缓冲)
4. 将分配到的内存初始化为零值。

   保证了对象实例在 Java 代码中可以不用初始化。
5. 对对象进行必要设置

   将设置的信息放在对象的对象头中
6. 执行 init 方法

### 对象的内存布局

* 对象头

  1. 对象自身运行时数据（哈希锁、 GC 分代年龄、锁状态），被称为 “Mark Word”。  

     极小的空间存储尽量多的数据。
  
  2. 类型指针  
     对象指向类元数据的指针，不是所有虚拟机都必须在对象数据中保留类型指针。如果是数组，还必须记录数组长度。

* 实例数据

  对象存储的真正有效信息，代码中所定义的各种字段信息。存储顺序受虚拟机分配策略和字段在源码中的定义顺序影响。
  
* 对齐填充

  占位符作用

### 对象的访问定位

Java 程序通过栈上的 reference 数据操作堆上的具体对象。

#### 句柄

Java 堆中划分出一块区域作为句柄池，reference 存储的就是句柄的地址，句柄中包含的是对象具体实例数据和类型数据各自的具体地址信息。

![句柄](http://picbed.jianghs.com/JVM-%E5%8F%A5%E6%9F%84.jpeg)

优点:
reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。

#### 直接指针

Java 堆需考虑如何放置访问对象类型数据信息，reference 中存储的直接就是对象地址。

![直接指针](http://picbed.jianghs.com/JVM-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.jpeg)

优点:
速度更快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。
